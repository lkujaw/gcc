1  GNAT

   Invoke the GNAT compilation system to build a program, compile a
   file, bind a program, link a program, split a source file into
   multiple units, preprocess a source file, or generate
   cross-reference information.


2  Model_Of_Compilation

   Although similar to that used by other languages, such as C and C++,
   GNAT's compilation model is substantially different from the
   traditional Ada compilation models, which are based on a library.


3  Source_Representation

   Ada source programs are represented in standard text files, using
   Latin-1 coding. Latin-1 is ASCII with the additional characters used
   for representing foreign languages (see HELP GNAT COMPILE
   /IDENTIFIER_CHARACTER_SET) for support of non-USA character sets). The
   format effector characters are represented using their standard ASCII
   encodings, as follows:

   o Vertical tab, 16#0B#
   o Horizontal tab, 16#09#
   o Carriage return, 16#0D#
   o Line feed, 16#0A#
   o Form feed, 16#0C#

   Each file contains a single Ada compilation unit, including any
   pragmas associated with the unit. For example, this means you must
   place a package declaration (a package "spec") and the corresponding
   body in separate files. An Ada "compilation" (which is a sequence of
   compilation units) is represented using a sequence of files.
   Similarly, you will place each subunit or child unit in a separate
   file.

   The file name is determined by the name of the unit the file contains.
   The name is formed by taking the full expanded name of the unit and
   replacing the separating dots with hyphens and using lower case for
   all letters except that a hyphen in the second character position is
   replaced by a plus sign. The filetype is ADS for a spec and ADB for a
   body.

   Following these rules can result in very long file names if
   corresponding unit names are very long (for example, if child units or
   subunits are heavily nested). An option is available to shorten such
   long file names (called file name "krunching").  Of course, no file
   shortening algorithm can guarantee uniqueness over all possible unit
   names; if file name krunching is used it is your responsibility to
   ensure no name clashes occur.


3  An_Ada_Program

   An Ada program consists of a set of source files, and the first step
   in compiling the program is to generate the corresponding object
   files.  These are generated by compiling a subset of these source
   files.  The files you need to compile are the following:

   o If a package spec has no body, compile the package spec to produce
     the object file for the package.

   o If a package has both a spec and a body, compile the body to produce
     the object file for the package. The source file for the package spec
     need not be compiled in this case since there is only one object
     file, which contains the code for both the spec and body of the
     package.

   o For a subprogram, compile the subprogram body to produce the object
     file for the subprogram. The spec, if one is present, is as usual in
     a separate file, and need not be compiled.

   o In the case of subunits, only compile the parent unit.  A single
     object file is generated for the entire subunit tree, which includes
     all the subunits.

   o Compile child units completely independently from their parent
     units (though, of course, the spec of the parent unit must be
     present).

   o Do not compile Generic units (specs and bodies).

   The preceeding rules describe the set of files that must be compiled
   to generate the object files for a program. Each object file has the
   same name as the corresponding source file, except that the filetype
   is OBJ as usual.

   You may wish to compile other files for the purpose of checking
   syntactic and semantic correctness. For example, in the case where a
   package has a separate spec and body, you would not normally compile
   the spec.  However, it is convenient in practice to compile the spec
   to make sure it is correct before compiling clients ofthis spec, since
   such compilations will fail if there is an error in the spec.

   GNAT provides the option for compiling such files purely for the
   purposes of checking correctness; such compilations are not required
   as part of the process of building a program.


3 File_Dependencies

   A given object file clearly depends on the source file which is
   compiled to produce it. Here we are using "depends" in the sense of
   the UNIX "make" utility; in other words, an object file depends on a
   source file if changes to the source file require the object file to
   be recompiled.

   In addition to this basic dependency, a given object may depend on
   additional source files as follows:

   o If a file being compiled with's a unit "X", the object file depends
     on the file containing the spec of unit "X". This includes files
     that are with'ed implicitly either because they are parents of
     with'ed child units or they are runtime units required by the
     language constructs used in a particular unit.

   o If a file being compiled instantiates a library level generic unit,
     the object file depends on both the spec and body files for this
     generic unit.

   o If a file being compiled instantiates a generic unit defined within
     a package, the object file depends on the body file for the package
     as well as the spec file.

   o If a file being compiled contains a call to a subprogram for which
     pragma Inline applies and inlining is activated with the
     /INLINE qualifier, the object file depends on the file
     containing the body of this subprogram as well as on the file
     containing the spec.

   o The object file for a parent unit depends on the body files for
     all subunits of the parent unit.

   These rules are applied transitively: if unit "A" with's unit "B",
   whose elaboration calls an inlined procedure in package "C", the
   object file for unit "A" will depend on the body of "C", in file
   C.ADB.

   The set of dependent files described by these rules includes all the
   files on which the unit is semantically dependent, as described in the
   Ada 95 Language Reference Manual. However it is larger because of the
   inclusion of generic, inline, and subunit dependencies.

   An object file must be recreated by recompiling the corresponding
   source file if any of the source files on which it depends are
   modified. For example, if the "make" utility is used to control
   compilation, the rule for an Ada object file must mention all the
   source files on which the object file depends.


3  Binding_And_Linking

   When using languages such as C and C++, the only remaining step in
   building an executable program once the source files have been
   compiled is linking the object modules together.  This means it is
   possible to link an inconsistent version of a program in which two
   units have included different versions of the same header.

   The rules in Ada do not permit such an inconsistent program to be
   built.  For example, if two clients have different versions of the
   same package, it is not possible to build a program containing these
   two clients.  These rules are enforced by the GNAT binder, which also
   determines an elaboration order consistent with the Ada rules.

   The GNAT binder is run after all the object files for a program have
   been compiled. It is given the name of the main program unit, and from
   this it determines the set of units required by the program, reading
   the corresponding ALI files. It generates error messages if the
   program is inconsistent or if no valid order of elaboration exists.

   If no errors are detected, the binder produces a main program, in C,
   that contains calls to the required elaboration procedures, followed
   by a call to the main program. This C program is compiled using the
   C compiler included in the GNAT system to generate the object file for
   the main program. The name of the C file is B_xxx.C where "xxx" is the
   name of the main program unit.

   Finally, the linker is used to build the resulting executable program,
   using the object from the main program from the bind step as well as
   the object files for the Ada units of the program.


3  Mixed_Language_Programming

   You build a program that contains some Ada files and some other
   language files in one of two ways, depending on whether the main
   program is in Ada or not.

   If the main program is in Ada, you proceed as follows:
   Compile the Ada units to produce a set of object files and ALI files.

   o Compile the other language files to generate object files.
   o Run the Ada binder on the Ada main program.
   o Compile the Ada main program.
   o Link the Ada main program, Ada objects and other language objects.

   If the main program is in some language other than Ada, you use a
   special option of the binder to generate callable routines to
   initialize and finalize the Ada units. You must insert calls to these
   routines in the main program, or some other appropriate point.  The
   call to initialize the Ada units must occur before the first Ada
   subprogram is called, and the call to finalize the Ada units must
   occur after the last Ada subprogram returns. You use the same
   procedure for building the program as described previously.  In this
   case, however, the binder places the initialization and finalization
   subprograms into file B_xxx.C instead of the main program.


3  C_Model_Comparison

   The GNAT model of compilation is close to the C and C++ models. You
   can think of Ada specs as corresponding to header files in C. As in C,
   you don't need to compile specs; they are compiled when they are used.
   The Ada "with" is similar in effect to the "#include" of a C header.

   One notable difference is that, in Ada, you may compile specs
   separately to check them for semantic and syntactic accuracy. This is
   not always possible with C headers because they are fragments of
   programs that have no specific syntactic or semantic rules.

   The other major difference is the requirement for running the binder,
   which performs two important functions. First, it checks for
   consistency. In C or C++, the only defense against putting together
   inconsistent programs is outside the compiler, in a make file, for
   example. The binder satisfies the Ada requirement that it be
   impossible to construct an inconsistent program when the compiler is
   used in normal mode.

   The other important function of the binder is to deal with elaboration
   issues. There are also elaboration issues in C++ that are handled
   automatically.  This automatic handling has the advantage of being
   simpler to use, but the C++ programmer has no control over
   elaboration.  Where GNAT BIND might complain there was no valid order
   of elaboration, a C++ compiler would simply construct a program that
   malfunctioned at runtime.


3  Traditional_Ada_Model_Comparison

   This entry is intended to be useful to Ada programmers who have
   previously used an Ada compiler (such as DEC Ada) implementing the
   traditional Ada library model, as described in the Ada 95 Languages
   Reference Manual.  If you have not used such a system, you need not
   read this entry.

   In GNAT, there no "library" in the normal sense. Instead, the set of
   source files themselves acts as the library. Compiling Ada programs
   does not generate any centralized information, but rather an object
   file and a ALI file, which are of interest only to the binder and
   linker.

   In a traditional system, the compiler reads information not only from
   the source file being compiled, but also from the centralized library.
   This means that the effect of a compilation depends on what has been
   previously compiled. In particular:

   o When a unit is with'ed, the unit seen by the compiler corresponds
     to the version of the unit most recently compiled into the library.

   o Inlining is effective only if the necessary body has already been
     compiled into the library.

   o Compiling a unit may obsolete other units in the library.

   In GNAT, compiling one unit never affects the compilation of any other
   units since the compiler reads only source files. Only changes to
   source files can affect the results of a compilation. In particular:

   o When a unit is with'ed, the unit seen by the compiler corresponds
     to the source version of the unit that is currently accessible to
     the compiler.

   o Inlining requires the appropriate source files for the package or
     subprogram bodies to be available to the compiler. Inlining is
     always effective, independent of the order in which units are
     complied.

   o Compiling a unit never affects any other compilations. The editing
     of sources may cause previous compilations to be out of date if
     they depended on the source file being modified.

   The important result of these differences are that order of
   compilation is never significant in GNAT. There is no situation in
   which you are required to do one compilation before another. What
   shows up as order of compilation requirements in the traditional Ada
   library becomes, in GNAT, simple source dependencies; in other words,
   it shows up as a set of rules saying what source files must be present
   when a file is compiled.


2  BIND

   Invoke the GNAT binder.

   Format:

     GNAT BIND [main-program-ALI file]

     GNAT BIND /NOMAIN [ALI file1] [ALI file2] ...


3  Overview

   The GNAT BIND command performs four separate functions:

   o Checks that a program is consistent, in accordance with the rules in
     chapter 10 of the Ada Language Reference Manual. In particular, error
     messages are generated if a program uses inconsistent versions of a
     given unit.

   o Checks that an acceptable order of elaboration exists for the program
     and issues an error message if it cannot find an order of elaboration
     satisfying the rules in Chapter 10 of the Ada Language Reference
     Manual.

   o Generates a main program incorporating the given elaboration order.
     This program is a small C source file that must be subsequently
     compiled using the C compiler. The two most important functions of
     this program are to call the elaboration routines of units in an
     appropriate order and to call the main program.

   o Determines the set of object files required by the given main
     program.  This information is output as comments in the generated
     C program, to be read by the GNAT LINK command used to link the
     Ada application.


3  Parameters

    Specify the filename of the main program either without any filetype
    or with a filetype or ALI or else a list of similar filenames if
    there is no main program (specify /NOMAIN in that case).


3  Qualifiers


/BIND_FILE

	/BIND_FILE[=bind-file-option]

   Specifies the language of the binder generated file.

	ADA (D)		Binder file is Ada.

	C 		Binder file is 'C'.


/BUILD_LIBRARY

	/BUILD_LIBRARY=xxx

    Binds the units for library building. In this case the adainit and
    adafinal procedures are rename to xxxinit and xxxfinal. Implies
    /NOMAIN.


/CURRENT_DIRECTORY

	/CURRENT_DIRECTORY (D)
	/NOCURRENT_DIRECTORY

   Look for source, library or object files in the default directory.


/DEBUG

	/DEBUG[=debug-level]
	/NODEBUG

    Specify level of debugging information generated for the elaboration
    routine.  See corresponding qualifier for GNAT COMPILE.


/ELABORATION_DEPENDENCIES

	/ELABORATION_DEPENDENCIES
	/NOELABORATION_DEPENDENCIES (D)

   Output complete list of elaboration-order dependencies, showing the
   reason for each dependency. This output can be rather extensive but may
   be useful in diagnosing problems with elaboration order. The output is
   written to SYS$OUTPUT.


/ERROR_LIMIT

	/ERROR_LIMIT=nnn

   Limit number of detected errors to nnn (1-999).

/EXTERNAL_REFERENCE

	/EXTERNAL_REFERENCE="name=val"

   Specifies an external reference to the project manager. Useful only if
   /PROJECT_FILE is used.

   Example:
      /EXTERNAL_REFERENCE="DEBUG=TRUE"


/HELP

	/HELP

   Output usage information.


/INITIALIZE_SCALARS

	/INITIALIZE_SCALARS[=scalar-option]

   Indicate how uninitialized scalar values for which a pragma
   Initialize_Scalars applies should be initialized.
   scalar-option may be one of the following:

      INVALID (D)  Initialize with an invalid value.
      LOW          Initialize with the lowest valid value of the subtype.
      HIGH         Initialize with the highest valid value of the subtype.


/LIBRARY_SEARCH

	/LIBRARY_SEARCH=(direc[,...])

	When looking for library and object files look also in directories
	specified.


/LINKER_OPTION_LIST

	/NOLINKER_OPTION_LIST (D)
	/LINKER_OPTION_LIST

        Output linker options to SYS$OUTPUT.  Includes library search paths,
        contents of pragmas Ident and Linker_Options, and libraries added
        by GNAT BIND.


/LIST_RESTRICTIONS

	/NOLIST_RESTRICTIONS (d)
	/LIST_RESTRICTIONS

   Generate list of pragma Rerstrictions that could be applied to the current
   unit. This is useful for code audit purposes, and also may be used
   to improve code generation in some cases.


/MAIN

	/MAIN (D)

   The main program is in Ada.

	/NOMAIN

   The main program is not in Ada.


/MESSAGES_PROJECT_FILE

	/MESSAGES_PROJECT_FILE[=messages-option]

   Specifies the "verbosity" of the parsing of project files.
   messages-option may be one of the following:

      DEFAULT (D)   No messages are output if there is no error or warning.

      MEDIUM        A small number of messages are output.

      HIGH          A great number of messages are output, most of them not
                    being useful for the user.

/NOOUTPUT

	/NOOUTPUT

   Check only. Do not generate the binder output file.

   In this mode the binder performs all error checks but does not generate
   an output file.


/NOSTD_INCLUDES

	/NOSTD_INCLUDES

    Do not look for sources the in the system default directory.


/NOSTD_LIBRARIES

	/NOSTD_LIBRARIES

    Do not look for library files in the system default directory.


/OBJECT_LIST

	/NOOBJECT_LIST (D)
	/OBJECT_LIST

    Output full names of all the object files that must be linker to provide
    the Ada component of the program. The output is written to SYS$OUTPUT.


/ORDER_OF_ELABORATION

	/NOORDER_OF_ELABORATION (D)
	/ORDER_OF_ELABORATION

   Output chosen elaboration order. The output is written to SYS$OUTPUT.


/OUTPUT

	/OUTPUT=filename

   File name to use for the program containing the elaboration code.


/PESSIMISTIC_ELABORATION

	/PESSIMISTIC_ELABORATION

   Causes the binder to choose a "pessimistic" elaboration order, i.e. one
   which is most likely to cause elaboration order problems. This can be
   useful in testing portable code to make sure that there are no missing
   elaborate pragmas.

/PROJECT_FILE

	/PROJECT_FILE=filename

   Specifies the main project file to be used. The project files rooted
   at the main project file will be parsed before the invocation of the binder.
   The source and object directories to be searched will be communicated
   to the binder through logical names ADA_INCLUDE_PATH and ADA_OBJECTS_PATH.

/READ_SOURCES

	/READ_SOURCES[=(keyword[,...])]
	/NOREAD_SOURCES

   The following keyword are accepted:

	ALL (D)		Require source files to be present. In this mode, the
			binder insists on being able to locate all source files
			that are referenced and checks their consistency.  In
			normal mode, if a source file cannot be located it is
			simply ignored. If you specify the ALL keyword, a
			missing source file is an error.

	NONE		Exclude source files. In this mode, the binder only
			checks that ALI files are consistent with one another.
			Source files are not accessed.  The binder runs faster
			in this mode, and there is still a guarantee that the
			resulting program is self-consistent.

			If a source file has been edited since it was last
			compiled and you specify the NONE keyword, the binder
			will not detect that the object file is out of date
			with the source file.

			This is the same as specifying /NOREAD_SOURCES.

	AVAILABLE	Check that object files are consistent with one
			another and are consistent with any source files that
			can be located.


/RENAME_MAIN

	/RENAME_MAIN=xxx

   Renames the generated main program from main to xxx.
   This is useful in the case of some cross-building environments, where
   the actual main program is separate from the one generated
   by GNAT BIND.


/REPORT_ERRORS

	/REPORT_ERRORS[=(keyword[,...])]
	   VERBOSE (D)
	   BRIEF
	   DEFAULT
	/NOREPORT_ERRORS

   With the DEFAULT keyword (which is not the default when the binder is
   run from GNAT BIND) or the /NOREPORT_ERRORS qualifier, brief error
   messages are generated to SYS$ERROR.  If the VERBOSE keyword is
   present, a header is written to SYS$OUTPUT and any error messages are
   directed to SYS$OUTPUT  All that is written to SYS$ERROR is a brief
   summary message.

   If the BRIEF keyword is specified, the binder will generate brief error
   messages to SYS$ERROR even if verbose mode is specified. This is
   relevant only when used together with the VERBOSE keyword or /VERBOSE
   qualifier.


/RESTRICTION_LIST

	/NORESTRICTION_LIST (D)
	/RESTRICTION_LIST

   Generate list of pragma Rerstrictions that could be applied to the current
   unit.
   This is useful for code audit purposes, and also may be used to improve
   code generation in some cases.


/RUNTIME_SYSTEM

	/RUNTIME_SYSTEM=xxx

    Binds against an alternate runtime system named xxx or RTS-xxx.


/SEARCH

	/SEARCH=(directory[,...])

   When looking for source or object files also look in directories
   specified.

   This is the same as specifying both /LIBRARY_SEARCH and /SOURCE_SEARCH
   for a directory.


/SHARED

	/SHARED (D)
	/NOSHARED

    Link against a shared GNAT run time when available.


/SOURCE_SEARCH

	/SOURCE_SEARCH=(directory[,...])

    When looking for source files also look in directories specified.


/TIME_SLICE

	/TIME_SLICE=nnn

   Set the time slice value to nnn milliseconds. A value of zero means no
   time slicing and also indicates to the tasking run time to match as
   close as possible to the annex D requirements of the RM.


/TIME_STAMP_CHECK

	/TIME_STAMP_CHECK (D)

   Time stamp errors will be treated as errors.

	/NOTIME_STAMP_CHECK

   Ignore time stamp errors. Any time stamp error messages are treated as
   warning messages. This switch essentially disconnects the normal
   consistency checking, and the resulting program may have undefined
   semantics if inconsistent units are present.

   This means that /NOTIME_STAMP_CHECK should be used only in unusual
   situations, with extreme care.


/VERBOSE

	/VERBOSE (D)
	/NOVERBOSE

   Equivalent to /REPORT_ERRORS=VERBOSE.


/WARNINGS

	/WARNINGS[=(keyword[,...])]
	/NOWARNINGS

   The following keywords are supported:

	NORMAL (D)	Print warning messages and treat them as warning.
	SUPPRESS	Suppress all warning messages (same as /NOWARNINGS).
	ERROR		Treat any warning messages as fatal errors


/ZERO_MAIN

	/NOZERO_MAIN (D)
	/ZERO_MAIN

   Normally the binder checks that the unit name given on the command line
   corresponds to a suitable main subprogram. When /ZERO_MAIN is used,
   a list of ALI files can be given, and the execution of the program
   consists of elaboration of these units in an appropriate order.


3  Examples

   $ GNATBIND HELLO.ALI

	The main program "Hello" (source program in HELLO.ADB) is bound using
	the standard switch settings. The generated main program is
	B_HELLO.C. This is the normal, default use of the binder.

   $ GNATBIND MAIN_PROGRAM.ALI /OUTPUT=MAINPROG.C /READ_SOURCES=NONE -
       /ELABORATION_DEPENDENCIES

	The main program "Main_Program" (source program in MAIN_PROGRAM.ADB_
	is bound, excluding source files from the consistency checking. A full
	list of elaboration dependencies is output to SYS$OUTPUT, and the file
	MAINPROG.C is generated.

   $ GNATBIND /NOMAIN MATH.ALI DBASE.ALI /OUTPUT=ADA-CONTROL.C

	The main program is in a language other than Ada, but calls to
	subprograms in packages "Math" and "Dbase" appear. This command
	generates the file ADA-CONTROL.C containing the "adainit" and
	"adafinal" routines to be called before and after accessing the Ada
	subprograms.


2  CHOP

   Split a single file into multiple files, one per unit.

   Format:

     GNAT CHOP input-filename [output-directory]


3  Overview

   The basic compilation model of GNAT requires a file submitted to the
   compiler have only one unit and there must be a strict correspondence
   between the file name and the unit name.

   The GNAT CHOP utility allows both of these rules to be relaxed,
   allowing GNAT to process files which contain multiple compilation
   units and files with arbitrary file names. The approach used by GNAT
   CHOP is to read the specified file and generate one or more output
   files, containing one unit per file and with proper file names as
   required by GNAT.

   If you want to permanently restructure a set of "foreign" files so
   that they match the GNAT rules and do the remaining development using
   the GNAT structure, you can simply use GNAT CHOP once, generate the
   new set of files and work with them from that point on.

   Alternatively, if you want to keep your files in the "foreign" format,
   perhaps to maintain compatibility with some other Ada compilation
   system, you can set up a procedure where you use GNAT CHOP each time
   you compile, regarding the source files that it writes as temporary
   files that you throw away.

   Note that COMPILE qualifiers are also allowed.


3  Parameters

input-filename

   The file name of the file to be chopped.  There are no restrictions on
   the form of this file name.  The file itself contains one or more Ada
   files, in normal GNAT format, concatenated together.


output-directory

   An optional directory name, which specifies where the chopped files
   are to be placed.


3  Qualifiers

/COMPILATION

	/NOCOMPILATION (D)
	/COMPILATION

   Compilation mode, handle configuration pragmas strictly according to
   RM rules.

/FILE_NAME_MAX_LENGTH

	/FILE_NAME_MAX_LENGTH[=nnn]

   Limit generated file names to NNN (default of 8) characters. This is
   useful if the resulting set of files is required to be interoperable
   with systems like MS-DOS which limit the length of file names.


/HELP

	/NOHELP (D)
	/HELP

   Print usage information.


/OVERWRITE

	/NOOVERWRITE (D)
	/OVERWRITE

   Overwrite existing file names. Normally GNAT CHOP regards it as a
   fatal error situation if there is already a file with the same name as
   a file it would otherwise output. The /OVERWRITE qualifier bypasses
   this check, and any such existing files will be silently overwritten.


/PRESERVE

	/NOPRESERVE (D)
	/PRESERVE

   Causes the file modification time stamp of the input file to be preserved
   and used for the time stamp of the output file(s). This may be useful for
   preserving coherency of time stamps in an enviroment where gnatchop is used
   as part of a standard build process.


/QUIET

	/NOQUIET (D)
	/QUIET

   Work quietly, only output warnings and errors.


/REFERENCE

	/NOREFERENCE (D)
	/REFERENCE

   Generate "Source_Reference" pragmas. Use this qualifier if the output
   files are regarded as temporary and development is to be done in terms
   of the original unchopped file. The /REFERENCE qualifier causes
   "Source_Reference" pragmas to be inserted into each of the generated
   files to refers back to the original file name and line number.  The
   result is that all error messages refer back to the original unchopped
   file.

   In addition, the debugging information placed into the object file
   (when the /DEBUG qualifier of GNAT COMPILE or GNAT MAKE is specified)
   also refers back to this original file so that tools like profilers
   and debuggers will give information in terms of the original unchopped
   file.


/VERBOSE

	/NOVERBOSE (D)
	/VERBOSE

   The version number and copyright notice are output, as well as exact
   copies of the gnat1 commands spawned to obtain the chop control
   information.


3  Examples

   $ GNAT CHOP /OVERWRITE HELLO_S.ADA DISK$GNAT:[ICHIBIAH.FILES]

	Chops the source file HELLO_S.ADA. The output files will be placed in
	the directory DISK$GNAT:[ICHBIAH.FILES], overwriting any files with
	matching names in that directory (no files in the current directory
	are modified).

   $ GNAT CHOP /REFERENCE COLLECT.

	Chops the source file COLLECT into the current directory. All output
        files have "Source_Reference" pragmas, so error messages will refer
        back to the file COLLECT. with proper line numbers.

   $ GNAT CHOP ARCHIVE.

	Chops the source file ARCHIVE. into the current directory.  One useful
	application of GNAT CHOP is in sending sets of sources around, for
	example in email messages. The required sources are simply
	concatenated (for example, using the APPEND /NEW command), and then
        GNAT CHOP is used at the other end to reconstitute the original
        file names.


2  COMPILE

   Invoke the GNAT compiler to compile an Ada program.

   Format:

     GNAT COMPILE input-file


3  Parameters

input-file

   The name of the file containing the Ada source program to be compiled.


3  Qualifiers

/83

	/NO83 (D)
	/83

   Although GNAT is primarily an Ada 95 compiler, it accepts this
   qualifier to specify that an Ada 83 mode program is being compiled. If
   you specify this qualifier, GNAT rejects Ada 95 extensions and applies
   Ada 83 semantics. It is not possible to guarantee this qualifier does
   a perfect job; for example, some subtle tests of pathological cases,
   such as are found in ACVC tests that have been removed from the ACVC
   suite for Ada 95, may not compile correctly. However for practical
   purposes, using this qualifier should ensure that programs that
   compile correctly under the /83 qualifier can be ported reasonably
   easily to an Ada 83 compiler. This is the main use of this qualifier.

   With few exceptions (most notably the need to use "<>" on
   unconstrained generic formal parameters), it is not necessary to use
   this qualifier switch when compiling Ada 83 programs, because, with
   rare and obscure exceptions, Ada 95 is upwardly compatible with Ada
   83. This means that a correct Ada 83 program is usually also a correct
   Ada 95 program.


/95

	/95 (D)

   Same as /NO83.

	/NO95

   Same as /83.


/ASM

	/NOASM (D)
	/ASM

   Use to cause the assembler source file to be generated, using S as the
   filetype, instead of the object file.  This may be useful if you need
   to examine the generated assembly code.


/CHECKS

	/NOCHECKS
	/CHECKS[=(keyword[,...])]

   If you compile with the default options, GNAT will insert many runtime
   checks into the compiled code, including code that performs range
   checking against constraints, but not arithmetic overflow checking for
   integer operations (including division by zero) or checks for access
   before elaboration on subprogram calls.  All other runtime checks, as
   required by the Ada 95 Reference Manual, are generated by default.

   You may specify one or more of the following keywords to the /CHECKS
   qualifier to modify this behavior:

	DEFAULT         The behavior described above. This is the default
			if the /CHECKS qualifier is not present on the
			command line. Same as /NOCHECKS.

	OVERFLOW	Enables overflow checking for integer operations and
			checks for access before elaboration on subprogram
			calls. This causes GNAT to generate slower and larger
			executable programs by adding code to check for both
			overflow and division by zero (resulting in raising
			"Constraint_Error" as required by Ada semantics).
			Similarly, GNAT does not generate elaboration check
			by default, and you must specify this keyword to
			enable them.

			Note that this keyword does not affect the code
			generated for any floating-point operations; it
			applies only to integer operations. For floating-point,
			GNAT has the "Machine_Overflows" attribute set to
			"False" and the normal mode of operation is to generate
			IEEE NaN and infinite values on overflow or invalid
			operations (such as dividing 0.0 by 0.0).

	ELABORATION	Enables dynamic checks for access-before-elaboration
			on subprogram calls and generic instantiations. 

	ASSERTIONS	The pragmas "Assert" and "Debug" normally have no
			effect and are ignored. This keyword causes "Assert"
			and "Debug" pragmas to be activated.

	SUPPRESS_ALL	Suppress all runtime checks as though you have "pragma
			Suppress (all_checks)" in your source. Use this switch
			to improve the performance of the code at the expense
			of safety in the presence of invalid data or program
			bugs.

	DEFAULT		Suppress the effect of any option OVERFLOW or
			ASSERTIONS.

	FULL (D)	Similar to OVERFLOW, but suppress the effect of any
			option ELABORATION or SUPPRESS_ALL.

   These keywords only control the default setting of the checks.  You
   may modify them using either "Suppress" (to remove checks) or
   "Unsuppress" (to add back suppressed checks) pragmas in your program
   source.


/COMPRESS_NAMES

	/NOCOMPRESS_NAMES (D)
	/COMPRESS_NAMES

   Compress debug information and external symbol name table entries.
   In the generated debugging information, and also in the case of long
   external names, the compiler uses a compression mechanism if the name
   is very long.  This compression method uses a checksum, and avoids trouble
   on some operating systems which have difficulty with very long names.


/CONFIGURATION_PRAGMAS_FILE

	/CONFIGURATION_PRAGMAS_FILE=file

   Specify a configuration pragmas file that need to be taken into account.


/CURRENT_DIRECTORY

	/CURRENT_DIRECTORY (D)
	/NOCURRENT_DIRECTORY

   Look for source files in the default directory.


/DEBUG

	/DEBUG[=debug-level]
	/NODEBUG

   Specifies how much debugging information is to be included in
   the resulting object fie.

   'debug-level' is one of the following:

	SYMBOLS (D)	Include both debugger symbol records and traceback
			in the object file.

	ALL		Include debugger symbol records, traceback plus
			extra debug information in the object file.

	NONE		Excludes both debugger symbol records and traceback
			from the object file.  Same as /NODEBUG.

	TRACEBACK	Includes only traceback records in the object
			file. This is the default when /DEBUG is not used.


/DISTRIBUTION_STUBS

	/NODISTRIBUTION_STUBS (D)
	/DISTRIBUTION_STUBS[=dist-opt]

   'dist-opt' is either RECEIVER (the default) or SENDER and indicates
   that stubs for use in distributed programs (see the Distributed
   Systems Annex of the Ada RM) should be generated.


/ERROR_LIMIT

	/NOERROR_LIMIT (D)
	/ERROR_LIMIT=nnn

   NNN is a decimal integer in the range of 1 to 999 and limits the
   number of error messages to be generated to that number.  Once that
   number has been reached, the compilation is abandoned.
   Specifying 999 is equivalent to /NOERROR_LIMIT.


/EXPAND_SOURCE

	/NOEXPAND_SOURCE (D)
	/EXPAND_SOURCE

   Produces a listing of the expanded code in Ada source form. For
   example, all tasking constructs are reduced to appropriate run-time
   library calls.


/EXTERNAL_REFERENCE

	/EXTERNAL_REFERENCE="name=val"

   Specifies an external reference to the project manager. Useful only if
   /PROJECT_FILE is used.

   Example:
      /EXTERNAL_REFERENCE="DEBUG=TRUE"


/FILE_NAME_MAX_LENGTH

	/FILE_NAME_MAX_LENGTH=nnn

   Activates file name "krunching". NNN, a decimal integer in the range
   1-999, indicates the maximum allowable length of a file name (not
   including the ADS or ADB filetype. The default is not to enable file
   name krunching.


/FORCE_ALI

	/NOFORCE_ALI (D)
	/FORCE_ALI

   In normal operation mode, the .ALI file is not generated if any
   illegalities are detected in the program. The use of this qualifier
   forces generation of the .ALI file. This file is marked as being
   in error, so it cannot be used for binding purposes, but it does contain
   reasonably complete cross-reference information, and thus may be useful
   for use by tools (e.g. semantic browing tools or integrated development
   environments) that are driven from the .ALI file.


/HELP

	/NOHELP (D)
	/HELP

   Output usage information.


/IDENTIFIER_CHARACTER_SET

	/NOIDENTIFIER_CHARACTER_SET (D)
	/IDENTIFIER_CHARACTER_SET=char-set

   Normally GNAT recognizes the Latin-1 character set in source program
   identifiers, as described in the reference manual. This qualifier
   causes GNAT to recognize alternate character sets in identifiers.
   'char-set' is one of the following strings indicating the character
   set:

	DEFAULT (D)	Equivalent to 1, below. Also equivalent to
			/NOIDENTIFIER_CHARACTER_SET.

	1		The basic character set is Latin-1. This character
			set is defined by ISO standard 8859, part 1. The lower
			half (character codes 16#00# ... 16#7F#) is identical
			to standard ASCII coding, but the upper half is used
			to represent additional characters. This includes
			extended letters used by European languages, such as
			the umlaut used in German.

			You may use any of these extended characters freely
			in character or string literals. In addition, the
			extended characters that represent letters can be
			used in identifiers.

	2		Latin-2 letters allowed in identifiers, with uppercase
			and lowercase equivalence.

	3		Latin-3 letters allowed in identifiers, with uppercase
			and lower case equivalence.

	4		Latin-4 letters allowed in identifiers, with uppercase
			and lower case equivalence.

	PC		IBM PC code page 437.  This code page is the normal
			default for PCs in the U.S. It corresponds to the
			original IBM PC character set. This set has some, but
			not all, of the extended Latin-1 letters, but these
			letters do not have the same encoding as Latin-1. In
			this mode, these letters are allowed in identifiers
			with uppercase and lowercase equivalence.

	PC850		This code page (850) is a modification of 437 extended
			to include all the Latin-1 letters, but still not with
			the usual Latin-1 encoding. In this mode, all these
			letters are allowed in identifiers with uppercase and
			lower case equivalence.

	FULL_UPPER	Any character in the range 80-FF allowed in
			identifiers, and all are considered distinct.  In
			other words, there are no uppercase and lower case
			equivalences in this range.

	NO_UPPER	No upper-half characters in the range 80-FF are
			allowed in identifiers.  This gives Ada 95
			compatibility for identifier names.

	WIDE		GNAT allows wide character codes to appear in
			character and string literals, and also optionally
			in identifiers.  See the /WIDE_CHARACTER_ENCODING
			qualifier for information on encoding formats.


/IMMEDIATE_ERRORS

	/NOIMMEDIATE_ERRORS (D)
	/IMMEDIATE_ERRORS

   Causes errors to be displayed as soon as they are encountered, rather than
   after compilation is terminated. If GNAT terminates prematurely or goes into
   an infinite loop, the last error message displayed may help to pinpoint
   the culprit.


/INLINE

	/NOINLINE (D)
	/INLINE[=keyword]

   Selects the level of inlining for your program.  In the absence of this
   qualifier, GNAT does not attempt inlining across units and does not need
   to access the bodies of subprograms for which "pragma Inline" is specified
   if they are not in the current unit.

   The supported keywords are as follows:

	PRAGMA (D)	Recognize and process "Inline" pragmas.  However,
			for the inlining to actually occur, optimization
			must be enabled.  This enables inlining across unit
			boundaries, that is, inlining a call in one unit of
			a subprogram declared in a with'ed unit. The compiler
			will access these bodies, creating an extra source
			dependency for the resulting object file, and where
			possible, the call will be inlined.

			This qualifier also turns on full optimization and
			requests GNAT to try to attempt automatic inlining
			of small subprograms within a unit.

			Specifying /OPTIMIZE=NONE will disable the main effect
			of this qualifier, but you may specify other
			optimization options, to get either lower
			(/OPTIMIZE=SOME) or higher (/OPTIMIZE=UNROLL_LOOPS)
			levels of optimization.

	FULL		Front end inlining. The front end inlining activated
			by this switch is generally more extensive, and quite
			often more effective than the standard PRAGMA inlining
			mode. It will also generate additional dependencies.

	SUPPRESS	Suppresses all inlining, even if other optimization
			or inlining switches are set.


/LIST

	/NOLIST (D)
	/LIST

   Cause a full listing of the file to be generated.


/LONGJMP_SETJMP

	/NOLONGJMP_SETJMP (D)
	/LONGJMP_SETJMP

   Causes the longjmp/setjmp approach to be used for exception handling.

   The default mechanism for OpenVMS is zero cost exceptions. This qualifier
   can be used to modify this default, but it must be used for all units
   in the partition, including all run-time library units. One way to achieve
   this is to use the /ALL_FILES and /FORCE_COMPILE for gnatmake.
   This option is rarely used. One case in which it may be advantageous is
   in an application where exception raising is common and the overall
   performance of the application is improved by favoring exception
   propagation.


/MAX_LINE_LENGTH

	/MAX_LINE_LENGTH=nnn

   Set maximum line length.
   The length of lines must not exceed the given value nnn.


/MESSAGES_PROJECT_FILE

	/MESSAGES_PROJECT_FILE[=messages-option]

   Specifies the "verbosity" of the parsing of project files.
   messages-option may be one of the following:

      DEFAULT (D)   No messages are output if there is no error or warning.

      MEDIUM        A small number of messages are output.

      HIGH          A great number of messages are output, most of them not
                    being useful for the user.


/NO_GNAT_ADC

	/NO_GNAT_ADC

   Cause the compiler to ignore any configuration pragmas file GNAT.ADC in the
   default directory. Implied by qualifier /PROJECT_FILE. Often used in
   in conjunction with qualifier /CONFIGURATION_PRAGMAS_FILE.


/NOLOAD

	/NOLOAD

   Cause the compiler to operate in semantic check mode with full
   checking for all illegalities specified in the reference manual, but
   without generation of any source code (no object or ALI file
   generated).

   Since dependent files must be accessed, you must follow the GNAT
   semantic restrictions on file structuring to operate in this mode:

   o The needed source files must be accessible.
   o Each file must contain only one compilation unit.
   o The file name and unit name must match.

   The output consists of error messages as appropriate. No object file
   or ALI file is generated. The checking corresponds exactly to the
   notion of legality in the Ada reference manual.

   Any unit can be compiled in semantics-checking-only mode, including
   units that would not normally be compiled (generic library units,
   subunits, and specifications where a separate body is present).


/NOSTD_INCLUDES

	/NOSTD_INCLUDES

   Do not look in the default directory for source files of the runtime.


/OPTIMIZE

	/NOOPTIMIZE (D)
	/OPTIMIZE[=(keyword[,...])]

   Selects the level of optimization for your program.  The supported
   keywords are as follows:

	ALL (D)		Perform most optimizations, including those that
			may be expensive.

	NONE		Do not do any optimizations.  Same as /NOOPTIMIZE.

	SOME            Perform some optimizations, but omit ones that
			are costly.

	DEVELOPMENT	Same as SOME.

	INLINING	Full optimization, and also attempt automatic inlining
			of small subprograms within a unit

	UNROLL_LOOPS	Try to unroll loops.  This keyword may be specified
			with any keyword above other than NONE.  Loop
			unrolling usually, but not always, improves the
			performance of programs.


/PROJECT_FILE

	/PROJECT_FILE=filename

   Specifies the main project file to be used. The project files rooted at the
   main project file will be parsed before the invocation of the compiler.
   The source and object directories to be searched will be communicated
   to the compiler through logical names ADA_INCLUDE_PATH and ADA_OBJECTS_PATH.

/REPORT_ERRORS

	/NOREPORT_ERRORS (D)
	/REPORT_ERRORS[=(keyword[,...])]

   Change the way errors are reported.  The following keywords are
   supported:

	VERBOSE (D)	Verbose mode. Full error output with source lines
			to SYS$OUTPUT.

	BRIEF		Generate the brief format error messages to
			SYS$OUTPUT as well as the verbose format message or
			full listing.

	FULL		Normally, the compiler suppresses error messages that
			are likely to be redundant. This keyword causes all
			error messages to be generated. One particular effect
			is for the case of references to undefined variables.
			If a given variable is referenced several times, the
			normal format of messages produces one error.  With
			FULL, each undefined reference produces a separate
			error message.

	IMMEDIATE	Normally, the compiler saves up error messages and
			generates them at the end of compilation in proper
			sequence.  This keyword causes error messages to be
			generated as soon as they are detected. The use of
			IMMEDIATE usually causes error messages to be
			generated out of sequence. Use it when the compiler
			blows up due to an internal error.  In this case, the
			error messages may be lost. Sometimes blowups are
			the result of mishandled error messages, so you may
			want to run with this keyword to determine whether
			any error messages were generated.

      DEFAULT           Turn off VERBOSE and BRIEF.  Same as /NOREPORT_ERRORS.


/REPRESENTATION_INFO

	/NOREPRESENTATION_INFO (D)
	/REPRESENTATION_INFO[=(keyword[,...])]

   This qualifier controls output from the compiler of a listing showing
   representation information for declared types and objects.

	ARRAYS (D)	Size and alignment information is listed for
			declared array and record types.

	NONE		no information is output (equivalent to omitting
			the /REPRESENTATION_INFO qualifiers).

	OBJECTS		Size and alignment information is listed for all
			declared types and objects.

	SYMBOLIC	Symbolic expression information for values that
			are computed at run time for variant records.

	DEFAULT		Equivalent to ARRAYS.


/RUNTIME_SYSTEM

	/RUNTIME_SYSTEM=xxx

    Build against an alternate runtime system named xxx or RTS-xxx.


/SEARCH

	/SEARCH=(directory[,...])

    When looking for source files also look in directories specified.


/STYLE_CHECKS

	/NOSTYLE_CHECKS (D)
	/STYLE_CHECKS[=(keyword,[...])]

   Normally, GNAT permits any code layout consistent with the reference
   manual requirements.  This qualifier imposes style checking on the
   input source code.  The following keywords are supported:

	ALL_BUILTIN (D)		Equivalent to the following list of options:
				3, ATTRIBUTE, BLANKS, COMMENTS, END, VTABS,
				HTABS, IF_THEN, KEYWORD, LAYOUT, LINE_LENGTH,
				PRAGMA, REFERENCES, SPECS, TOKEN.

	1 .. 9			Specify indentation level from 1 to 9.
				The general style of required indentation is as
				specified by the examples in the Ada Reference
				Manual. Full line comments must be aligned with
				the -- starting on a column that is a multiple
				of the alignment level.

	ATTRIBUTE		Check attribute casing.
				Attribute names, including the case of keywords
				such as digits used as attributes names,
				must be written in mixed case, that is,
				the initial letter and any letter following an
				underscore must be uppercase.
				All other letters must be lowercase.

	BLANKS			Blanks not allowed at statement end.
				Trailing blanks are not allowed at the end of
				statements. The purpose of this rule, together
				with option HTABS (no horizontal tabs), is to
				enforce a canonical format for the use of
				blanks to separate source tokens.

	COMMENTS		Check comments.
				Comments must meet the following set of rules:

				  * The "--" that starts the column must either
				    start in column one, or else at least one
				    blank must precede this sequence.

				  * Comments that follow other tokens on a line
				    must have at least one blank following the
				    "--" at the start of the comment.

				  * Full line comments must have two blanks
				    following the "--" that starts the comment,
				    with the following exceptions.

				  * A line consisting only of the "--"
				    characters, possibly preceded by blanks is
				    permitted.

				  * A comment starting with "--x" where x is
				    a special character is permitted. This
				    allows proper processing of the output
				    generated by specialized tools including
				    gnatprep (where --! is used) and the SPARK
				    annnotation language (where --# is used).
				    For the purposes of this rule, a special
				    character is defined as being in one of the
				    ASCII ranges 16#21#..16#2F# or
				    16#3A#..16#3F#.

				  * A line consisting entirely of minus signs,
				    possibly preceded by blanks, is permitted.
				    This allows the construction of box
				    comments where lines of minus signs are
				    used to form the top and bottom of the box.

				  * If a comment starts and ends with "--" is
				    permitted as long as at least one blank
				    follows the initial "--". Together with
				    the preceding rule, this allows the
				    construction of box comments, as shown in
				    the following example:
           

				---------------------------
				-- This is a box comment --
				-- with two text lines.  --
				---------------------------

	END			Check end/exit labels.
				Optional labels on end statements ending
				subprograms and on exit statements exiting
				named loops, are required to be present.

	GNAT			Enforces a set of style conventions that
				correspond to the style used in the GNAT
				source code.  All compiler units are always
				compile with this keyword specified.

				You can find the full documentation for the
				style conventions imposed by this keyword
				in the body of the package "Style" in the
				compiler sources.

				You should not normally use this keyword.
				However, you MUST use it for compiling any
				language-defined unit, or for adding children
				to any language-defined unit other than
				"Standard".

	HTABS			No horizontal tabs.
				Horizontal tab characters are not permitted in
				the source text. Together with the BLANKS
				(no blanks at end of line) option, this
				enforces a canonical form for the use of blanks
				to separate source tokens.

	IF_THEN			Check if-then layout.
				The keyword then must appear either on the
				same line as the corresponding if, or on a line
				on its own, lined up under the if with at least
				one non-blank line in between containing all or
				part of the condition to be tested.

	KEYWORD			Check keyword casing.
				All keywords must be in lower case (with the
				exception of keywords such as digits used as
				attribute names to which this check does not
				apply).

	LAYOUT			Check layout.
				Layout of statement and declaration constructs
				must follow the recommendations in the Ada
				Reference Manual, as indicated by the form of
				the syntax rules. For example an else keyword
				must be lined up with the corresponding if
				keyword.

				There are two respects in which the style rule
				enforced by this check option are more liberal
				than those in the Ada Reference Manual.
				First in the case of record declarations,
				it is permissible to put the record keyword on
				the same line as the type keyword, and then
				the end in end record must line up under type.
				For example, either of the following two
				layouts is acceptable:

				type q is record
				   a : integer;
				   b : integer;
				end record;

				type q is
				   record
				      a : integer;
				      b : integer;
				   end record;

				Second, in the case of a block statement,
				a permitted alternative is to put the block
				label on the same line as the declare or begin
				keyword, and then line the end keyword up under
				the block label. For example both the following
				are permitted:

     

				Block : declare
				   A : Integer := 3;
				begin
				   Proc (A, A);
				end Block;

				Block :
				   declare
				      A : Integer := 3;
				   begin
				      Proc (A, A);
				   end Block;

				The same alternative format is allowed for
				loops. For example, both of the following are
				permitted:

     

				Clear : while J < 10 loop
				   A (J) := 0;
				end loop Clear;

				Clear :
				   while J < 10 loop
				      A (J) := 0;
				   end loop Clear;



	LINE_LENGTH		Check maximum line length.
				The length of source lines must not exceed 79
				characters, including any trailing blanks
				The value of 79 allows convenient display on
				an 80 character wide device or window, allowing
				for possible special treatment of 80 character
				lines.

	ORDERED_SUBPROGRAMS	Check order of subprogram bodies.
				All subprogram bodies in a given scope (e.g.
				a package body) must be in alphabetical order.
				The ordering rule uses normal Ada rules for
				comparing strings, ignoring casing of letters,
				except that if there is a trailing numeric
				suffix, then the value of this suffix is used
				in the ordering (e.g. Junk2 comes before
				Junk10).

	NONE			The default behavior.  Same as /NOSTYLE_CHECKS.

	PRAGMA			Check pragma casing.
				Pragma names must be written in mixed case,
				that is, the initial letter and any letter
				following an underscore must be uppercase.
				All other letters must be lowercase.

	REFERENCES		Check references.
				All identifier references must be cased in the
				same way as the corresponding declaration.
				No specific casing style is imposed on
				identifiers. The only requirement is for
				consistency of references with declarations.

	RM_COLUMN_LAYOUT	Enforce the layout conventions suggested by
				the examples and syntax rules of the Ada
				Language Reference Manual. For example, an
				"else" must line up with an "if" and code in
				the "then" and "else" parts must be indented.
				The compiler considers violations of the
				layout rules a syntax error if you specify
				this keyword.

	SPECS			Check separate specs.
				Separate declarations ("specs") are required
				for subprograms (a body is not allowed to serve
				as its own declaration). The only exception is
				that parameterless library level procedures are
				not required to have a separate declaration.
				This exception covers the most frequent form of
				main program procedures.

	STANDARD_CASING		Check casing of entities in Standard.
				Any identifier from Standard must be cased to
				match the presentation in the Ada Reference
				Manual (for example, Integer and ASCII.NUL).

	TOKEN			Check token spacing.
				The following token spacing rules are enforced:

				  * The keywords abs and not must be followed
				    by a space.

				  * The token => must be surrounded by spaces.

				  * The token <> must be preceded by a space or
				    a left parenthesis.

				  * Binary operators other than ** must be
				    surrounded by spaces. There is no
				    restriction on the layout of the ** binary
				    operator.

 				  * Colon must be surrounded by spaces.

				  * Colon-equal (assignment) must be surrounded
				    by spaces.

				  * Comma must be the first non-blank character
				    on the line, or be immediately preceded by
				    a non-blank character, and must be followed
				    by a space.

				  * If the token preceding a left paren ends
				    with a letter or digit, then a space must
				    separate the two tokens.

				  * A right parenthesis must either be the
				    first non-blank character on a line, or it
				    must be preceded by a non-blank character.

				  * A semicolon must not be preceded by
				    a space, and must not be followed by
				    a non-blank character.

				  * A unary plus or minus may not be followed
				    by a space.

				  * A vertical bar must be surrounded by
				    spaces.

				In the above rules, appearing in column one is
				always permitted, that is, counts as meeting
				either a requirement for a required preceding
				space, or as meeting a requirement for no
				preceding space.

				Appearing at the end of a line is also always
				permitted, that is, counts as meeting either
				a requirement for a following space,
				or as meeting a requirement for no following
				space.

	VTABS			No form feeds or vertical tabs.
				Form feeds or vertical tab characters are not
				permitted in the source text.


/SYNTAX_ONLY

	/NOSYNTAX_ONLY (D)
	/SYNTAX_ONLY

   Run GNAT in syntax checking only mode.  You can check a series of
   files in a single command, and can use wild cards to specify such a
   group of files.

   You may use other qualifiers in conjunction with this qualifier. In
   particular, /LIST and /REPORT_ERRORS=VERBOSE are useful to control the
   format of any generated error messages.

   The output is simply the error messages, if any. No object file or ALI
   file is generated by a syntax-only compilation. Also, no units other
   than the one specified are accessed. For example, if a unit "X" with's
   a unit "Y", compiling unit "X" in syntax check only mode does not
   access the source file containing unit "Y".

   Normally, GNAT allows only a single unit in a source file. However,
   this restriction does not apply in syntax-check-only mode, and it is
   possible to check a file containing multiple compilation units
   concatenated together. This is primarily used by the GNAT CHOP
   command.


/TRACE_UNITS

	/TRACE_UNITS
	/NOTRACE_UNITS

   This switch that does for the frontend what /VERBOSE does for the
   backend. The system prints the name of each unit, either a compilation
   unit or nested unit, as it is being analyzed.


/TREE_OUTPUT

	/TREE_OUTPUT
	/NOTREE_OUTPUT

   Cause GNAT to write the internal tree for a unit to a file (with the
   filetype ATB for a body or ATS for a spec).  This is not normally
   required, but is used by separate analysis tools. Typically these
   tools do the necessary compilations automatically, so you should never
   have to specify this switch in normal operation.


/TRY_SEMANTICS

	/TRY_SEMANTICS
	/NOTRY_SEMANTICS

   In normal operation mode the compiler first parses the program and
   determines if there are any syntax errors. If there are, appropriate
   error messages are generated and compilation is immediately
   terminated.  This qualifier tells GNAT to continue with semantic
   analysis even if syntax errors have been found.  This may enable the
   detection of more errors in a single run. On the other hand, the
   semantic analyzer is more likely to encounter some internal fatal
   error when given a syntactically invalid tree.


/UNIQUE_ERROR_TAG

	/NOUNIQUE_ERROR_TAG (D)
	/UNIQUE_ERROR_TAG

   Tag compiler error messages with the string "error: ".


/UNITS_LIST

	/NOUNITS_LIST (D)
	/UNITS_LIST

   Print a list of units required by this compilation on SYS$OUTPUT.  The
   listing includes all units on which the unit being compiled depends
   either directly or indirectly.


/UPPERCASE_EXTERNALS

	/NOUPPERCASE_EXTERNALS (D)
	/UPPERCASE_EXTERNALS

   Fold default and explicit external names in pragmas Import and Export
   to uppercase for compatibility with the default behavior of DEC C.


/VALIDITY_CHECKING

	/VALIDITY_CHECKING[=(keyword,[...])]

   Control level of validity checking.

	DEFAULT (D)     In this mode checks are made to prevent
			erroneous behavior in accordance with the RM.
			Notably extra checks may be needed for case
			statements and subscripted array assignments.

	NONE		No special checks for invalid values are
			performed. This means that references to
			uninitialized variables can cause erroneous
			behavior from constructs like case statements
			and subscripted array assignments. In this
			mode, invalid values can lead to erroneous
			behavior.

	FULL		Every assignment is checked for validity, so
			that it is impossible to assign invalid values.
			The RM specifically allows such assignments,
			but in this mode, invalid values can never be
			assigned, and an attempt to perform such an
			assignment immediately raises Constraint_Error.
			This behavior is allowed (but not required) by
			the RM. This mode is intended as a debugging aid,
			and may be useful in helping to track down
			uninitialized variables. It may be useful to
			use this in conjunction with the Normalize_Scalars
			pragma which attempts to initialize with invalid
			values where possible.


/VERBOSE

	/VERBOSE
	/NOVERBOSE

   Show commands generated by the GCC driver. Normally used only for
   debugging purposes or if you need to be sure what version of the
   compiler you are executing.


/WARNINGS

	/NOWARNINGS

   Suppress the output of all warning messages from the GNAT front end.
   Note that it does not suppress warnings from the gcc back end. 

	/WARNINGS[=(keyword[,...])]

   In addition to error messages, corresponding to illegalities as
   defined in the reference manual, the compiler detects two kinds of
   warning situations.  First, the compiler considers some constructs
   suspicious and generates a warning message to alert you to a possible
   error. Second, if the compiler detects a situation that is sure to
   raise an exception at runtime, it generates a warning message.

   You may specify the following keywords to change this behavior:

	DEFAULT (D) 		The default behavior above.

	ALL			Activate all optional warnings.
				Activates most optional warning messages, see
				remaining list in this section for details on
				optional warning messages that can be
				individually controlled. The warnings that are
				not turned on by this option are
				BIASED_ROUNDING, IMPLICIT_DEREFERENCE, HIDING
				and ELABORATION. All other optional Ada
				warnings are turned on.

	NOALL			Suppress all optional errors.
				Suppresses all optional warning messages that
				can be activated by option ALL.

	ALL_GCC			Request additional messages from the GCC
				backend.  Most of these are not relevant
				to Ada.

	BIASED_ROUNDING		Activate warnings on biased rounding.
				If a static floating-point expression has
				a value that is exactly half way between two
				adjacent machine numbers, then the rules of Ada
				(Ada Reference Manual, section 4.9(38)) require
				that this rounding be done away from zero, even
				if the normal unbiased rounding rules at run
				time would require rounding towards zero.

				This warning message alerts you to such
				instances where compile-time rounding and
				run-time rounding are not equivalent. If it is
				important to get proper run-time rounding,
				then you can force this by making one of the
				operands into a variable. The default is that
				such warnings are not generated. Note that
				/WARNINGS=ALL does not affect the setting of
				this warning option.

	NOBIASED_ROUNDING	Suppress warnings on biased rounding.
				Disable warnings on biased rounding.

	CONDITIONALS		Activate warnings for conditional
				Expressions used in tests that are known
				to be True or False at compile time. The
				default is that such warnings are not
				generated.

	NOCONDITIONALS		Suppress warnings for conditional
				expressions used in tests that are known
				to be True or False at compile time.

	IMPLICIT_DEREFERENCE	Activate warnings on implicit dereferencing.
				The use of a prefix of an access type in an
				indexed component, slice, or selected component
				without an explicit .all will generate
				a warning. With this warning enabled, access
				checks occur only at points where an explicit
				.all appears in the source code (assuming no
				warnings are generated as a result of this
				option). The default is that such warnings are
				not generated. Note that /WARNINGS=ALL does not
				affect the setting of this warning option.

	NOIMPLICIT_DEREFERENCE	Suppress warnings on implicit dereferencing.
				in indexed components, slices, and selected
				components.

	ELABORATION		Activate warnings on missing pragma
				Elaborate_All statements. The default is
				that such warnings are not generated.

	NOELABORATION		Suppress warnings on missing pragma
				Elaborate_All statements.

	ERRORS			Warning messages are to be treated as errors.
				The warning string still appears, but the
				warning messages are counted as errors, and
				prevent the generation of an object file.

	HIDING			Activate warnings on hiding declarations.
				A declaration is considered hiding if it is
				for a non-overloadable entity, and it declares
				an entity with the same name as some other
				entity that is directly or use-visible. The
				default is that such warnings are not
				generated.

	NOHIDING		Suppress warnings on hiding declarations.

	IMPLEMENTATION		Activate warnings for a with of an internal
				GNAT implementation unit, defined as any unit
				from the Ada, Interfaces, GNAT, DEC or
				System hierarchies that is not documented in
				either the Ada Reference Manual or the GNAT
				Programmer's Reference Manual. Such units are
				intended only for internal implementation
				purposes and should not be with'ed by user
				programs. The default is that such warnings
		 		are generated.

	NOIMPLEMENTATION	Disables warnings for a with of an internal
				GNAT implementation unit.

	INEFFECTIVE_INLINE	Activate warnings on ineffective pragma Inlines
				Activates warnings for failure of front end
				inlining (activated by /INLINE=FULL) to inline
				a particular call. There are many reasons for
				not being able to inline a call, including most
				commonly that the call is too complex to
				inline. This warning can also be turned on
				using /INLINE=FULL.

	NOINEFFECTIVE_INLINE	Suppress warnings on ineffective pragma Inlines
				Suppresses warnings on ineffective pragma
				Inlines. If the inlining mechanism cannot
				inline a call, it will simply ignore the
				request silently.

	MODIFIED_UNREF		Activates warnings for variables that are
				assigned (using an initialization value or with
				one or more assignment statements) but whose
				value is never read. The warning is suppressed
				for volatile variables and also for variables
				that are renamings of other variables or for
				which an address clause is given. This warning
				can also be turned on using /WARNINGS/OPTIONAL.

	NOMODIFIED_UNREF	Disables warnings for variables that are
				assigned or initialized, but never read.

	NORMAL			Sets normal warning mode, in which enabled
				warnings are issued and treated as warnings
				rather than errors. This is the default mode.
				It can be used to cancel the effect of an
				explicit /WARNINGS=SUPPRESS or
				/WARNINGS=ERRORS. It also cancels the effect
				of the implicit /WARNINGS=ERRORS that is
				activated by the use of /STYLE=GNAT.

	OBSOLESCENT		Activates warnings for calls to subprograms
				marked with pragma Obsolescent and for use of
				features in Annex J of the Ada Reference
				Manual. In the case of Annex J, not all
				features are flagged. In particular use of the
				renamed packages (like Text_IO), use of package
				ASCII and use of the attribute 'Constrained are
				not flagged, since these are very common and
				would generate many annoying positive warnings.
				The default is that such warnings are not
				generated.

	NOOBSOLESCENT		Disables warnings on use of obsolescent
				features.

	OPTIONAL		Activate all optional warning messages.
				See other options under this qualifier
				for details on optional warning messages
				that can be individually controlled. The
				one exception is that /WARNINGS=OPTIONAL
				doesn't activate warnings for hiding
				variables (/WARNINGS=HIDING), so if this
				warning is required it must be explicitly
				set.

	NOOPTIONAL		Suppress all optional warning messages.
				See other options under this qualifier
				for details on optional warning messages
				that can be individually controlled.

	OVERLAYS		Activate warnings for possibly unintended
				initialization effects of defining address
				clauses that cause one variable to overlap
				another. The default is that such warnings
				are generated.

	NOOVERLAYS		Suppress warnings on possibly unintended
				initialization effects of defining address
				clauses that cause one variable to overlap
				another.

	REDUNDANT		Activate warnings for redundant constructs.
				In particular assignments of a variable to
				itself, and a type conversion that converts
				an object to its own type. The default
				is that such warnings are not generated.

	NOREDUNDANT		Suppress warnings for redundant constructs.

	SUPPRESS		Completely suppresse the output of all warning
				messages.  Same as /NOWARNINGS.

	UNCHECKED_CONVERSIONS	Activates warnings on unchecked conversions.
				Causes warnings to be generated for
				unchecked conversions when the two types are
				known at compile time to have different sizes.
				The default is that such warnings are
				generated.

	NOUNCHECKED_CONVERSIONS	Suppress warnings for unchecked conversions.

	UNINITIALIZED		Generate warnings for uninitialized variables.
				This is a GCC option, not an Ada option.
				You must also specify the /OPTIMIZE qualifier
				with a value other than NONE (in other words,
				this keyword works only if optimization is
				turned on).

	UNREFERENCED_FORMALS	Activate warnings on unreferenced formals.
				Causes a warning to be generated if a formal
				parameter is not referenced in the body of
				the subprogram. This warning can also be turned
				on using option ALL or UNUSED.

	NOUNREFERENCED_FORMALS	Suppress warnings on unreferenced formals.
				Suppresses warnings for unreferenced formal
				parameters. Note that the combination UNUSED
				followed by NOUNREFERENCED_FORMALS has the
				effect of warning on unreferenced entities
				other than subprogram formals.

	UNUSED			Activates warnings to be generated for entities
				that are defined but not referenced, and for
				units that are with'ed and not referenced. In
				the case of packages, a warning is also
			 	generated if no entities in the package are
				referenced. This means that if the package
				is referenced but the only references are in
				use clauses or renames declarations, a warning
				is still generated. A warning is also generated
				for a generic package that is with'ed but never
				instantiated.  In the case where a package or
				subprogram body is compiled, and there is a
				with on the corresponding spec that is only
			 	referenced in the body, a warning is also
				generated, noting that the with can be moved
				to the body. The default is that such warnings
				are not generated.

	NOUNUSED		Suppress warnings for unused entities and
				packages.

	VARIABLES_UNINITIALIZED	Activates warnings on unassigned variables.
				Causes warnings to be generated when a variable
				is accessed which may not be properly
				uninitialized.
				The default is that such warnings are
				generated.

	NOVARIABLES_UNINITIALIZED	Suppress warnings for uninitialized
					variables.


/WIDE_CHARACTER_ENCODING

	/NOWIDE_CHARACTER_ENCODING (D)
	/WIDE_CHARACTER_ENCODING[=encode-type]

   Specifies the mechanism used to encode wide characters.  'encode-type'
   is one of the following:

	BRACKETS (D)	A wide character is encoded as ["xxxx"] where XXXX
			are four hexadecimal digits representing the coding
			('Pos value) of the character in type
			Wide_Character. The hexadecimal digits may use upper
			or lower case letters.

			This notation can also be used for upper half
			Character values using the format ["xx"] where XX is
			two hexadecimal digits representing the coding ('Pos
			value) of the character in type Character (or
			Wide_Character). The hexadecimal digits may use upper
			of lower case.

	NONE		No wide characters are allowed.  Same
			as /NOWIDE_CHARCTER_ENCODING.

	HEX		In this encoding, a wide character is represented by
			the following five character sequence: ESC a b c d
			Where 'a', 'b', 'c', and 'd' are the four hexadecimal
			characters (using uppercase letters) of the wide
			character code. For example, ESC A345 is used to
			represent the wide character with code 16#A345#. This
			scheme is compatible with use of the full
			Wide_Character set.

	UPPER		The wide character with encoding 16#abcd# where the
			upper bit is on (in other words, "a" is in the range
			8-F) is represented as two bytes, 16#ab# and 16#cd#.
			The second byte may never be a format control
			character, but is not required to be in the upper
			half. This method can be also used for shift-JIS or
			EUC, where the internal coding matches the external
			coding.

	SHIFT_JIS	A wide character is represented by a two-character
			sequence, 16#ab# and 16#cd#, with the restrictions
			described for upper-half encoding as described above.
			The internal character code is the corresponding JIS
			character according to the standard algorithm for
			Shift-JIS conversion. Only characters defined in the
			JIS code set table can be used with this encoding
			method.

	UTF8		A wide character is represented using
			UCS Transformation Format 8 (UTF-8) as defined in Annex
			R of ISO 10646-1/Am.2.  Depending on the character
			value, the representation is a one, two, or three byte
			sequence:

			16#0000#-16#007f#: 2#0xxxxxxx#
			16#0080#-16#07ff#: 2#110xxxxx# 2#10xxxxxx#
			16#0800#-16#ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#

			where the xxx bits correspond to the left-padded bits
			of the the 16-bit character value. Note that all lower
			half ASCII characters are represented as ASCII bytes
			and all upper half characters and other wide characters
			are represented as sequences of upper-half (The full
			UTF-8 scheme allows for encoding 31-bit characters as
			6-byte sequences, but in this implementation, all UTF-8
			sequences of four or more bytes length will be treated
			as illegal).

	EUC		A wide character is represented by a two-character
			sequence 16#ab# and 16#cd#, with both characters being
			in the upper half. The internal character code is the
			corresponding JIS character according to the EUC
			encoding algorithm. Only characters defined in the JIS
			code set table can be used with this encoding method.


/XDEBUG

	/NOXDEBUG (D)
	/XDEBUG

   Output expanded source files for source level debugging.
   The expanded source (see /EXPAND_SOURCE) is written to files
   with names formed by appending "_DG" to the input file name,
   The debugging information generated by the /DEBUG qualifier will then
   refer to the generated file. This allows source level debugging using
   the generated code which is sometimes useful for complex code, for example
   to find out exactly which part of a complex construction raised an
   exception.


/XREF

	/XREF[=keyword]

   Normally the compiler generates full cross-referencing information in
   the .ALI file. This information is used by a number of tools,
   including GNAT FIND and GNAT XREF.

	GENERATE (D)		Generate cross-referencing information.

        SUPPRESS		Suppress cross-referencing information.
				This saves some space and may slightly
				speed up compilation, but means that some
				tools cannot be used.


2  FIND

   The compiler generates cross-referencing information, which is saved in
   the .ALI files. This information indicates where in the source each
   entity is declared and referenced.

   The tools XREF and FIND take advantage of this information to provide the
   user with the capability to easily locate the declaration and references
   to an entity. These tools are quite similar, the difference being that
   FIND is intended for locating definitions and/or references to a
   specified entity or entities, whereas XREF is oriented to generating a
   full report of all cross-references.


3  Parameters

pattern[:sourcefile[:line[:column]]]

   An entity will be output only if it matches the regular expression
   found in pattern.

   Omitting the pattern is equivalent to specifying *, which will match
   any entity. Note that if you do not provide a pattern, you have to
   provide both a sourcefile and a line.

   Entity names are given in Latin-1, with upper-lower case equivalence
   for matching purposes. At the current time there is no support for
   8-bit codes other than Latin-1, or for wide characters in identifiers.

   sourcefile:

   FIND will look for references, bodies or declarations of symbols
   referenced in sourcefile, at the specified line and at the specified
   column.

   line:

   A decimal integer identifying the line number containing the reference
   to the entity (or entities) to be located.

   column:

   A decimal integer identifying the exact location on the line of the
   first character of the identifier for the entity reference. Columns
   are numbered from 1.


filespec[,...]

   The search will be restricted to these files. If none are given, then
   the search will be done for every library file in the search path.
   These file must appear only after the pattern or sourcefile.


3  Qualifiers

/ALL_FILES

	/NOALL_FILES (D)
	/ALL_FILES

   If this switch is present, FIND and XREF will parse the read-only
   files found in the library search path. Otherwise, these files will
   be ignored. This option can be used to protect Gnat sources or your
   own libraries from being parsed, thus making FIND and XREF much
   faster, and their output much smaller.


/DERIVED_TYPE_INFORMATION

	/NODERIVED_TYPE_INFORMATION (D)
	/DERIVED_TYPE_INFORMATION

   Output the parent type reference for each matching derived types.


/EXPRESSIONS

	/NOEXPRESSIONS (D)
	/EXPRESSIONS

   By default, FIND accepts the simple regular expression set for pattern.
   If this switch is set, then the pattern will be considered as a full
   Unix-style regular expression.


/EXTERNAL_REFERENCE

	/EXTERNAL_REFERENCE="name=val"

   Specifies an external reference to the project manager. Useful only if
   /PROJECT_FILE is used.

   Example:
      /EXTERNAL_REFERENCE="DEBUG=TRUE"


/FULL_PATHNAME

	/NOFULL_PATHNAME (D)
	/FULL_PATHNAME

   If this switch is set, the output file names will be preceded by their
   directory (if the file was found in the search path). If this switch
   is not set, the directory will not be printed.


/IGNORE_LOCALS

	/NOIGNORE_LOCALS (D)
	/IGNORE_LOCALS

   If this switch is set, information is output only for library-level
   entities, ignoring local entities. The use of this switch may
   accelerate FIND and XREF.


/MESSAGES_PROJECT_FILE

	/MESSAGES_PROJECT_FILE[=messages-option]

   Specifies the "verbosity" of the parsing of project files.
   messages-option may be one of the following:

      DEFAULT (D)   No messages are output if there is no error or warning.

      MEDIUM        A small number of messages are output.

      HIGH          A great number of messages are output, most of them not
                    being useful for the user.


/NOSTD_INCLUDES

	/NOSTD_INCLUDES

   Do not look for sources in the system default directory.


/NOSTD_LIBRARIES

	/NOSTD_LIBRARIES

   Do not look for library files in the system default directory.


/OBJECT_SEARCH

	/OBJECT_SEARCH=(directory,...)

   When searching for library and object files, look in the specified
   directories. The order in which library files are searched is the same
   as for MAKE.


/PRINT_LINES

	/NOPRINT_LINES (D)
	/PRINT_LINES

   Output the content of the Ada source file lines were the entity was found.


/PROJECT

	/PROJECT=file

   Specify a project file to use. By default, FIND and XREF will try to
   locate a project file in the current directory.

   If a project file is either specified or found by the tools, then the
   content of the source directory and object directory lines are added
   as if they had been specified respectively by /SOURCE_SEARCH and
   /OBJECT_SEARCH.

   This qualifier is not compatible with /PROJECT_FILE


/PROJECT_FILE

	/PROJECT_FILE=filename

   Specifies the main project file to be used. The project files rooted
   at the main project file will be parsed before looking for sources.
   The source and object directories to be searched will be communicated
   to gnatfind  through logical names ADA_INCLUDE_PATH and ADA_OBJECTS_PATH.

/REFERENCES

	/NOREFERENCES (D)
	/REFERENCES

   By default, FIND will output only the information about the
   declaration, body or type completion of the entities. If this switch
   is set, the FIND will locate every reference to the entities in the
   files specified on the command line (or in every file in the search
   path if no file is given on the command line).


/SEARCH

	/SEARCH=(directory,...)

   Equivalent to:
   /OBJECT_SEARCH=(directory,...) /SOURCE_SEARCH=(directory,...)


/SOURCE_SEARCH

	/SOURCE_SEARCH=(directory,...)

   When looking for source files also look in the specified directories.
   The order in which source file search is undertaken is the same as for
   MAKE.


/TYPE_HIERARCHY

	/NOTYPE_HIERARCHY (D)
	/TYPE_HIERARCHY

   Output the type hierarchy for the specified type. It acts like the
   /DERIVED_TYPE_INFORMATION qualifier, but recursively from parent type
   to parent type. When this qualifier is specified it is not possible to
   specify more than one file.


2  KRUNCH

   Used to determine the krunched name for a given file, when krunched
   to a specified maximum length.


3  Parameters

file

   Filename to be krunched.


3  Qualifiers

/COUNT

	/COUNT=39 (D)
	/COUNT=nnn

   Limit file names to nnn characters (where nnn is a decimal
   integer). The maximum file name length is 39, but if you want to
   generate a set of files that would be usable if ported to a system
   with some different maximum file length, then a different value can
   be specified.


2  LIBRARY

   Build an alternate run-time library with specified configuration
   pragmas.


3  Qualifiers

/CONFIG

	/CONFIG=file

   File containing configuration pragmas.


/CREATE

	/CREATE=directory

   Directory to create and build alternate library in.


/DELETE

	/DELETE=directory

   Directory containing alternate library to be deleted.


/SET

	/SET=directory

   Directory containing alternate library to be made the current library.


2  LINK

   Link an Ada program by invoking the system linker with a correct list
   of object files and library references.  GNAT LINK automatically
   determines the list of files and references for the Ada part of a
   program. It uses the binder file generated by the binder to determine
   this list.

   Format:

     GNAT LINK mainprog-file [extra-objects]


3  Parameters

ali-file

   MAINPROG.ALI references the ALI file of the main program.  The ALI
   filetype of this file can be omitted. From this reference, GNAT LINK
   locates the corresponding binder file (B_MAINPROG.C) and, using the
   information in this file along with the list of non-Ada objects and
   linker options, constructs a LINK command file to create the
   executable.


extra-objects-and-libraries-and-shareables-and-options

   These parameters are passed to the linker uninterpreted. They
   typically include the names of object files for units written in other
   languages than Ada and any library references required to resolve
   references in any of these foreign language units, or in "pragma
   Import" statements in any Ada units.

   GNAT LINK determines the list of objects required by the Ada program
   and prepends them to the list of objects passed to the linker.  GNAT
   LINK also gathers any arguments set by the use of "pragma
   Linker_Options" and adds them to the list of arguments presented to
   the linker.


3  Qualifiers

   Any qualifiers not recognized are passed to the linker.


/BIND_FILE

	/BIND_FILE=[bind-file-option]

   Specifies the language of the binder generated file.

	ADA (D)		Binder file is Ada.

	C		Binder file is 'C'.


/DEBUG

	/NODEBUG (D)
	/DEBUG[=debug-option]

   Specifies the amount of debugging information included.  'debug-option'
   is one of the following:

	ALL (D)		Include full debugging information.

	NONE		Provide no debugging information.  Same as /NODEBUG.

	TRACEBACK	Provide sufficient debug information for a traceback.

	NOTRACEBACK	Same as NONE.


/EXECUTABLE

	/EXECUTABLE=exec-name

   'exec-name' specifies an alternative name for the generated executable
   program. If this qualifier switch is omitted, the executable is called
   the name of the main unit. So "$ GNAT LINK TRY.ALI" creates an
   executable called TRY.EXE.


/EXTERNAL_REFERENCE

	/EXTERNAL_REFERENCE="name=val"

   Specifies an external reference to the project manager. Useful only if
   /PROJECT_FILE is used.

   Example:
      /EXTERNAL_REFERENCE="DEBUG=TRUE"


/FORCE_OBJECT_FILE_LIST

	/NOFORCE_OBJECT_FILE_LIST (D)
	/FORCE_OBJECT_FILE_LIST

   Forces the generation of a file that contains commands for the linker.
   This is useful in some cases to deal with special situations where the
   command line length is exceeded.


/IDENTIFICATION

	/IDENTIFICATION="<string>"

   "<string>" specifies the string to be stored in the image file ident-
   ification field in the image header. It overrides any pragma Ident
   specified string.


/MESSAGES_PROJECT_FILE

	/MESSAGES_PROJECT_FILE[=messages-option]

   Specifies the "verbosity" of the parsing of project files.
   messages-option may be one of the following:

      DEFAULT (D)   No messages are output if there is no error or warning.

      MEDIUM        A small number of messages are output.

      HIGH          A great number of messages are output, most of them not
                    being useful for the user.

/NOCOMPILE

	/NOCOMPILE

   Do not compile the file generated by the binder.
   This may be used when a link is rerun with different options,
   but there is no need to recompile the binder generated file.


/NOINHIBIT-EXEC

	/NOINHIBIT-EXEC

   Delete executable if there are errors or warnings.


/NOSTART_FILES

        /NOSTART_FILES

   Link in default image initialization and startup functions.


/PROJECT_FILE

	/PROJECT_FILE=filename

   Specifies the main project file to be used. The project files rooted
   at the main project file will be parsed before the invocation of the linker.
   The source and object directories to be searched will be communicated
   to the linker through logical names ADA_INCLUDE_PATH and ADA_OBJECTS_PATH.


/RETURN_CODES

	/RETURN_CODES=POSIX (D)
	/RETURN_CODES=VMS

   Specifies the style of codes returned by Ada.Command_Line.Set_Exit_Status.

	POSIX (D)	Return Posix compatible exit codes.

	VMS		Return VMS compatible exit codes. The value returned
			is identically equal to the Set_Exit_Status parameter.


/STATIC

	/NOSTATIC (D)
	/STATIC

   Indicate to the linker that the link is static.


/VERBOSE

	/NOVERBOSE (D)
	/VERBOSE

   Causes additional information to be output, including a full list of
   the included object files. This switch option is most useful when you
   want to see what set of object files are being used in the link step.


/<other>

	/<other>

   Any other switch that will be transmited to the underlying linker.


2  LIST

   Utility that displays information about compiled units, including
   dependencies on the correspondings sources files, and consistency of
   compilations.


3  Parameters

object_or_ali_file

   File to be browsed.


3  Qualifiers

/ALL_UNITS

	/NOALL_UNITS (D)
	/ALL_UNITS

   Consider all units, including those of the predefined Ada library.
   Especially useful with /DEPENDENCIES.


/CURRENT_DIRECTORY

	/CURRENT_DIRECTORY (D)
	/NOCURRENT_DIRECTORY

   Look for source, library or object files in the default directory.


/DEPENDENCIES

	/NODEPENDENCIES (D)
	/DEPENDENCIES

   List sources from which specified units depend on.


/EXTERNAL_REFERENCE

	/EXTERNAL_REFERENCE="name=val"

   Specifies an external reference to the project manager. Useful only if
   /PROJECT_FILE is used.

   Example:
      /EXTERNAL_REFERENCE="DEBUG=TRUE"


/MESSAGES_PROJECT_FILE

	/MESSAGES_PROJECT_FILE[=messages-option]

   Specifies the "verbosity" of the parsing of project files.
   messages-option may be one of the following:

      DEFAULT (D)   No messages are output if there is no error or warning.

      MEDIUM        A small number of messages are output.

      HIGH          A great number of messages are output, most of them not
                    being useful for the user.


/NOSTD_INCLUDES

	/NOSTD_INCLUDES

   Do not look for sources of the run time in the standard directory.


/OBJECT_SEARCH

	/OBJECT_SEARCH=(directory,...)

   When looking for library and object files look also in the specified
   directories.

/OUTPUT
	/OUTPUT=(option,option,...)

	SOURCES (D)	Only output information about source files.

	DEPEND		List sources from which specified units depend on.

	OBJECTS		Only output information about object files.

	UNITS		Only output information about compilation units.

	OPTIONS		Output the list of options.

	VERBOSE		Output the complete source and object paths.
			Do not use the default column layout but instead
			use long format giving as much as information
			possible on each requested units, including
			special characteristics.


/PROJECT_FILE

	/PROJECT_FILE=filename

   Specifies the main project file to be used. The project files rooted
   at the main project file will be parsed before doing any listing.
   The source and object directories to be searched will be communicated
   to gnatlist through logical names ADA_INCLUDE_PATH and ADA_OBJECTS_PATH.

/SEARCH

	/SEARCH=(directory,...)

   Search the specified directories for both source and object files.

/SOURCE_SEARCH

	/SOURCE_SEARCH=(directory,...)

   When looking for source files also look in the specified directories.


2  MAKE

   As you work on a program, you keep track of which units you modify and
   make sure you not only recompile these units, but also any units that
   depend on units you have modified.

   The GNAT MAKE command takes care of these details automatically.

   Format:
     GNAT MAKE main-file


3  Overview

   A typical development cycle when working on an Ada program consists of
   the following steps:

   Edit some sources to fix bugs.

   o Add enhancements.
   o Compile all sources affected.
   o Rebind and relink.
   o Test.

   The third step can be tricky, because not only do the modified files
   have to be compiled, but any files depending on these files must also
   be recompiled. The dependency rules in Ada can be quite complex,
   especially in the presence of overloading, "use" clauses, generics
   and inlined subprograms.

   GNAT MAKE automatically takes care of the third and fourth steps of
   this process. It determines which sources need to be compiled,
   compiles them, and binds and links the resulting object files.

   Unlike some other Ada make programs, the dependencies are always
   accurately recomputed from the new sources. The source based approach
   of the GNAT compilation model makes this possible. This means that if
   changes to the source program cause corresponding changes in
   dependencies, they will always be tracked exactly correctly by GNAT
   MAKE.


3  Parameters

main-file

   The compilation unit that is the main program. There are two ways to
   specify this:

   o By giving the name of the compilation unit.  In this case GNAT MAKE
     will use the /SOURCE_SEARCH and /SEARCH qualifiers to locate the
     appropriate file.

   o By giving the name of the source containing it.  If no relative or
     absolute directory is specified, the input source file will be
     searched for in the directory where GNAT MAKE was invoked.  GNAT
     MAKE will not use the /SOURCE_SEARCH and /SEARCH qualifiers to
     locate the appropriate file.


3  Qualifiers

/83

	/83
	/NO83

   Although GNAT is primarily an Ada 95 compiler, it accepts this
   qualifier to specify that an Ada 83 mode program is being compiled. If
   you specify this qualifier, GNAT rejects Ada 95 extensions and applies
   Ada 83 semantics. It is not possible to guarantee this qualifier does
   a perfect job; for example, some subtle tests of pathological cases,
   such as are found in ACVC tests that have been removed from the ACVC
   suite for Ada 95, may not compile correctly. However for practical
   purposes, using this qualifier should ensure that programs that
   compile correctly under the /83 qualifier can be ported reasonably
   easily to an Ada 83 compiler. This is the main use of this qualifier.

   With few exceptions (most notably the need to use "<>" on
   unconstrained generic formal parameters), it is not necessary to use
   this qualifier switch when compiling Ada 83 programs, because, with
   rare and obscure exceptions, Ada 95 is upwardly compatible with Ada
   83. This means that a correct Ada 83 program is usually also a correct
   Ada 95 program.


/95

	/95

   Same as /NO83.

	/NO95

   Same as /83.


/ACTIONS

	/ACTIONS=(keyword[,...])

  GNAT MAKE default behavior is to check if the sources are up to date,
  compile those sources that are not up to date, bind the main source,
  then link the executable.

  With the /ACTIONS qualifier, GNAT MAKE may be restricted to one or
  two of these three steps:

  o Compile
  o Bind
  o Link

  
   You may specify one or more of the following keywords to the /ACTIONS
   qualifier:

	BIND            Bind only. Can be combined with /ACTIONS=COMPILE
			to do compilation and binding, but no linking.
			Can be combined with /ACTIONS=LINK to do binding and
			linking. When not combined with /ACTIONS=COMPILE,
			all the units in the closure of the main program must
			have been previously compiled and must be up to date.

	COMPILE         Compile only. Do not perform binding, except when
			/ACTIONS=BIND is also specified. Do not perform
			linking, except if both /ACTIONS=BIND and /ACTIONS=LINK
			are also specified.

	LINK            Link only. Can be combined with /ACTIONS=BIND to do
			binding and linking. Linking will not be performed
			if combined with /ACTIONS=COMPILE but not with
			/ACTIONS=BIND\. When not combined with /ACTIONS=BIND
			all the units in the closure of the main program must
			have been previously compiled and must be up to date,
			and the main program need to have been bound. 


/ALL_FILES

	/NOALL_FILES (D)
	/ALL_FILES

   Consider all files in the make process, even the GNAT internal system
   files (for example, the predefined Ada library files). By default,
   GNAT MAKE does not check these files (however, if there is an
   installation problem, it will be caught when GNAT MAKE binds your
   program). You may have to specify this qualifier if you are working on
   GNAT itself.  The vast majority of GNAT MAKE users never need to
   specify this switch.  All GNAT internal files with will be compiled
   with /STYLE_CHECK=GNAT.


/BINDER_QUALIFIERS

	/BINDER_QUALIFIERS

   Any qualifiers specified after this qualifier other than
   /COMPILER_QUALIFIERS, /LINKER_QUALIFIERS and /MAKE_QUALIFIERS will be
   passed to any GNAT BIND commands generated by GNAT MAKE.


/CHECKS

	/CHECKS[=(keyword[,...])]
	/NOCHECKS

   If you compile with the default options, GNAT will insert many runtime
   checks into the compiled code, including code that performs range
   checking against constraints, but not arithmetic overflow checking for
   integer operations (including division by zero) or checks for access
   before elaboration on subprogram calls.  All other runtime checks, as
   required by the Ada 95 Reference Manual, are generated by default.

   You may specify one or more of the following keywords to the /CHECKS
   qualifier to modify this behavior:

	DEFAULT         The behavior described above. This is the default
			if the /CHECKS qualifier is not present on the
			command line. Same as /NOCHECKS.

	OVERFLOW	Enables overflow checking for integer operations and
			checks for access before elaboration on subprogram
			calls. This causes GNAT to generate slower and larger
			executable programs by adding code to check for both
			overflow and division by zero (resulting in raising
			"Constraint_Error" as required by Ada semantics).
			Similarly, GNAT does not generate elaboration check
			by default, and you must specify this keyword to
			enable them.

			Note that this keyword does not affect the code
			generated for any floating-point operations; it
			applies only to integer operations. For floating-point,
			GNAT has the "Machine_Overflows" attribute set to
			"False" and the normal mode of operation is to generate
			IEEE NaN and infinite values on overflow or invalid
			operations (such as dividing 0.0 by 0.0).

	ELABORATION	Enables dynamic checks for access-before-elaboration
			on subprogram calls and generic instantiations. 

	ASSERTIONS	The pragmas "Assert" and "Debug" normally have no
			effect and are ignored. This keyword causes "Assert"
			and "Debug" pragmas to be activated.

	SUPPRESS_ALL	Suppress all runtime checks as though you have "pragma
			Suppress (all_checks)" in your source. Use this switch
			to improve the performance of the code at the expense
			of safety in the presence of invalid data or program
			bugs.

	DEFAULT		Suppress the effect of any option OVERFLOW or
			ASSERTIONS.

	FULL (D)	Similar to OVERFLOW, but suppress the effect of any
			option ELABORATION or SUPPRESS_ALL.

   These keywords only control the default setting of the checks.  You
   may modify them using either "Suppress" (to remove checks) or
   "Unsuppress" (to add back suppressed checks) pragmas in your program
   source.


/COMPILER_QUALIFIERS

	/COMPILER_QUALIFIERS

   Any qualifiers specified after this qualifier other than
   /BINDER_QUALIFIERS, /LINKER_QUALIFIERS and /MAKE_QUALIFIERS will be passed
   to any GNAT COMPILE commands generated by GNAT MAKE.


/COMPRESS_NAMES

	/NOCOMPRESS_NAMES (D)
	/COMPRESS_NAMES

   Compress debug information and external symbol name table entries.
   In the generated debugging information, and also in the case of long
   external names, the compiler uses a compression mechanism if the name
   is very long.  This compression method uses a checksum, and avoids trouble
   on some operating systems which have difficulty with very long names.


/CONDITIONAL_SOURCE_SEARCH

	/CONDITIONAL_SOURCE_SEARCH=(directory[,...])

   Equivalent to specifying the directory name in both the
   /SKIP_MISSING and /SOURCE_SEARCH qualifiers.  Use this qualifier
   to list directories containing the Ada library, if not in the
   standard place.


/CONFIGURATION_PRAGMAS_FILE

	/CONFIGURATION_PRAGMAS_FILE=file

   Specify a configuration pragmas file that need to be taken into account
   by the compiler.


/CONTINUE_ON_ERROR

	/NOCONTINUE_ON_ERROR (D)
	/CONTINUE_ON_ERROR

   Keep going. Continue as much as possible after a compilation error.
   To ease the programmer's task in case of compilation errors, the list
   of sources for which the compile fails is given when GNAT MAKE
   terminates.


/CURRENT_DIRECTORY

	/CURRENT_DIRECTORY (D)
	/NOCURRENT_DIRECTORY

   Look for source, library or object files in the default directory.


/DEBUG

	/DEBUG[=debug-level]
	/NODEBUG

   Specifies how much debugging information is to be included in
   the resulting object and executable files.

   'debug-level' is one of the following:

	SYMBOLS (D)	Include both debugger symbol records and traceback
			in the object and executable files.

	ALL		Include debugger symbol records, traceback plus
			extra debug information in the object and
			executable files.

	NONE		Excludes both debugger symbol records and traceback
			from the object and executable files.
			Same as /NODEBUG.

	TRACEBACK	Includes only traceback records in the object
			and executable files. This is the default when
			/DEBUG is not used.

	LINK		Include both debugger symbol records and traceback in
			the object and executable files (same as ALL).


/DEPENDENCIES_LIST

	/NODEPENDENCIES_LIST (D)
	/DEPENDENCIES_LIST

   Check if all objects are up to date. If they are, output the object
   dependences to SYS$OUTPUT in a form that can be directly exploited in
   a Unix-style Makefile. By default, each source file is prefixed with
   its (relative or absolute) directory name. This name is whatever you
   specified in the various /SOURCE_SEARCH and /SEARCH qualifiers.  If
   you also speficy the /QUIET qualifier, only the source file names,
   without relative paths, are output. If you just specify the
   /DEPENDENCY_LIST qualifier, dependencies of the GNAT internal system
   files are omitted.  This is typically what you want. If you also
   specify the /ALL_FILES qualifier, dependencies of the GNAT internal
   files are also listed. Note that dependencies of the objects in
   external Ada libraries (see the /SKIP_MISSING qualifier) are never
   reported.


/DISTRIBUTION_STUBS

	/NODISTRIBUTION_STUBS (D)
	/DISTRIBUTION_STUBS[=dist-opt]

   'dist-opt' is either RECEIVER (the default) or SENDER and indicates
   that stubs for use in distributed programs (see the Distributed
   Systems Annex of the Ada RM) should be generated.


/DIRECTORY_OBJECTS

	/DIRECTORY_OBJECTS=<file>

   Put all object files and .ALI files in <file>.
   This qualifier is not compatible with /PROJECT_FILE.


/DO_OBJECT_CHECK

	/NODO_OBJECT_CHECK (D)
	/DO_OBJECT_CHECK

   Don't compile, bind, or link. Output a single command that will
   recompile an out of date unit, if any. Repeated use of this option,
   followed by carrying out the indicated compilation, will eventually
   result in recompiling all required units.

   If any ALI is missing during the process, GNAT MAKE halts and
   displays an error message.


/ERROR_LIMIT

	/ERROR_LIMIT=nnn
	/NOERROR_LIMIT

   NNN is a decimal integer in the range of 1 to 999 and limits the
   number of error messages to be generated to that number.  Once that
   number has been reached, the compilation is abandoned.


/EXECUTABLE

	/EXECUTABLE=exec-name

   The name of the final executable program will be 'exec_name'. If this
   qualifier is omitted the default name for the executable will be the
   name of the input file with an EXE filetype.  You may prefix
   'exec_name' with a relative or absolute directory path.


/EXPAND_SOURCE

	/NOEXPAND_SOURCE (D)
	/EXPAND_SOURCE

   Produces a listing of the expanded code in Ada source form. For
   example, all tasking constructs are reduced to appropriate run-time
   library calls.


/EXTERNAL_REFERENCE

	/EXTERNAL_REFERENCE="name=val"

   Specifies an external reference to the project manager. Useful only if
   /PROJECT_FILE is used.

   Example:
      /EXTERNAL_REFERENCE="DEBUG=TRUE"


/FILE_NAME_MAX_LENGTH

	/FILE_NAME_MAX_LENGTH=nnn

   Activates file name "krunching". NNN, a decimal integer in the range
   1-999, indicates the maximum allowable length of a file name (not
   including the ADS or ADB filetype. The default is not to enable file
   name krunching.


/FORCE_ALI

	/NOFORCE_ALI (D)
	/FORCE_ALI

   In normal operation mode, the .ALI file is not generated if any
   illegalities are detected in the program. The use of this qualifier
   forces generation of the .ALI file. This file is marked as being
   in error, so it cannot be used for binding purposes, but it does contain
   reasonably complete cross-reference information, and thus may be useful
   for use by tools (e.g. semantic browing tools or integrated development
   environments) that are driven from the .ALI file.


/FORCE_COMPILE

	/NOFORCE_COMPILE (D)
	/FORCE_COMPILE

   Force recompilations. Recompile all sources, even though some object
   files may be up to date, but don't recompile predefined or GNAT
   internal files unless the /ALL_FILES qualfier is also specified.


/IDENTIFIER_CHARACTER_SET

	/IDENTIFIER_CHARACTER_SET=char-set
	/NOIDENTIFIER_CHARACTER_SET

   Normally GNAT recognizes the Latin-1 character set in source program
   identifiers, as described in the reference manual. This qualifier
   causes GNAT to recognize alternate character sets in identifiers.
   'char-set' is one of the following strings indicating the character
   set:

	1 (D)		The basic character set is Latin-1. This character
			set is defined by ISO standard 8859, part 1. The lower
			half (character codes 16#00# ... 16#7F#) is identical
			to standard ASCII coding, but the upper half is used
			to represent additional characters. This includes
			extended letters used by European languages, such as
			the umlaut used in German.

			You may use any of these extended characters freely
			in character or string literals. In addition, the
			extended characters that represent letters can be
			used in identifiers.

	2		Latin-2 letters allowed in identifiers, with uppercase
			and lowercase equivalence.

	3		Latin-3 letters allowed in identifiers, with uppercase
			and lower case equivalence.

	4		Latin-4 letters allowed in identifiers, with uppercase
			and lower case equivalence.

	PC		IBM PC code page 437.  This code page is the normal
			default for PCs in the U.S. It corresponds to the
			original IBM PC character set. This set has some, but
			not all, of the extended Latin-1 letters, but these
			letters do not have the same encoding as Latin-1. In
			this mode, these letters are allowed in identifiers
			with uppercase and lowercase equivalence.

	PC850		This code page (850) is a modification of 437 extended
			to include all the Latin-1 letters, but still not with
			the usual Latin-1 encoding. In this mode, all these
			letters are allowed in identifiers with uppercase and
			lower case equivalence.

	FULL_UPPER	Any character in the range 80-FF allowed in
			identifiers, and all are considered distinct.  In
			other words, there are no uppercase and lower case
			equivalences in this range.

	NO_UPPER	No upper-half characters in the range 80-FF are
			allowed in identifiers.  This gives Ada 95
			compatibility for identifier names.

	WIDE		GNAT allows wide character codes to appear in
			character and string literals, and also optionally
			in identifiers.  See the /WIDE_CHARACTER_ENCODING
			qualifier for information on encoding formats.



/IMMEDIATE_ERRORS

	/NOIMMEDIATE_ERRORS (D)
	/IMMEDIATE_ERRORS

   Causes errors to be displayed as soon as they are encountered, rather than
   after compilation is terminated. If GNAT terminates prematurely or goes into
   an infinite loop, the last error message displayed may help to pinpoint
   the culprit.


/IN_PLACE

	/NOIN_PLACE (D)
	/IN_PLACE

   In normal mode, GNAT MAKE compiles all object files and ALI files
   into the current directory. If the /IN_PLACE switch is used,
   then instead object files and ALI files that already exist are over-
   written in place. This means that once a large project is organized
   into separate directories in the desired manner, then GNAT MAKE will
   automatically maintain and update this organization. If no ALI files
   are found on the Ada object path, the new object and ALI files are
   created in the directory containing the source being compiled.


/INLINE

	/NOINLINE (D)
	/INLINE[=keyword]

   Selects the level of inlining for your program.  In the absence of this
   qualifier, GNAT does not attempt inlining across units and does not need
   to access the bodies of subprograms for which "pragma Inline" is specified
   if they are not in the current unit.

   The supported keywords are as follows:

	PRAGMA (D)	Recognize and process "Inline" pragmas.  However,
			for the inlining to actually occur, optimization
			must be enabled.  This enables inlining across unit
			boundaries, that is, inlining a call in one unit of
			a subprogram declared in a with'ed unit. The compiler
			will access these bodies, creating an extra source
			dependency for the resulting object file, and where
			possible, the call will be inlined.

			This qualifier also turns on full optimization and
			requests GNAT to try to attempt automatic inlining
			of small subprograms within a unit.

			Specifying /OPTIMIZE=NONE will disable the main effect
			of this qualifier, but you may specify other
			optimization options, to get either lower
			(/OPTIMIZE=SOME) or higher (/OPTIMIZE=UNROLL_LOOPS)
			levels of optimization.

	FULL		Front end inlining. The front end inlining activated
			by this switch is generally more extensive, and quite
			often more effective than the standard PRAGMA inlining
			mode. It will also generate additional dependencies.

	SUPPRESS	Suppresses all inlining, even if other optimization
			or inlining switches are set.


/LIBRARY_SEARCH

	/LIBRARY_SEARCH=(directory[,...])

   Add the specified directories to the list of directories in which the
   linker will search for libraries.


/LINKER_QUALIFIERS

	/LINKER_QUALIFIERS

   Any qualifiers specified after this qualifier other than
   /COMPILER_QUALIFIERS, /BINDER_QUALIFIERS and /MAKE_QUALIFIERS will be
   passed to any GNAT LINK commands generated by GNAT LINK.


/LIST

	/NOLIST (D)
	/LIST

   Cause a full listing of the file to be generated.


/LONGJMP_SETJMP

	/NOLONGJMP_SETJMP (D)
	/LONGJMP_SETJMP

   Causes the longjmp/setjmp approach to be used for exception handling.

   The default mechanism for OpenVMS is zero cost exceptions. This qualifier
   can be used to modify this default, but it must be used for all units
   in the partition, including all run-time library units. One way to achieve
   this is to use the /ALL_FILES and /FORCE_COMPILE for gnatmake.
   This option is rarely used. One case in which it may be advantageous is
   in an application where exception raising is common and the overall
   performance of the application is improved by favoring exception
   propagation.


/MAKE_QUALIFIERS

	/MAKE_QUALIFIERS

   Any qualifiers specified after this qualifier other than
   /COMPILER_QUALIFIERS, /BINDER_QUALIFIERS and /LINKER_QUALIFIERS
   are for the benefit of GNAT MAKE itself.


/MAPPING

	/NOMAPPING (D)
	/MAPPING

  Use a mapping file.  A mapping file is a way to communicate to the compiler
  two mappings: from unit names to file names (without any directory
  information) and from file names to path names (with full directory
  information). These mappings are used by the compiler to short-circuit
  the path search. When @code{gnatmake} is invoked with this switch,
  it will create a mapping file, initially populated by the project manager,
  if /PROJECT_File=  is used, otherwise initially empty. Each invocation
  of the compiler will add the newly accessed sources to the mapping file.
  This will improve the source search during the next invocations
   of the compiler


/MAX_LINE_LENGTH

	/MAX_LINE_LENGTH=nnn

   Set maximum line length.
   The length of lines must not exceed the given value nnn.


/MESSAGES_PROJECT_FILE

	/MESSAGES_PROJECT_FILE[=messages-option]

   Specifies the "verbosity" of the parsing of project files.
   messages-option may be one of the following:

      DEFAULT (D)   No messages are output if there is no error or warning.

      MEDIUM        A small number of messages are output.

      HIGH          A great number of messages are output, most of them not
                    being useful for the user.

/MINIMAL_RECOMPILATION

	/NOMINIMAL_RECOMPILATION (D)
	/MINIMAL_RECOMPILATION

   Specifies that the minimum necessary amount of recompilation
   be performed. In this mode GNAT MAKE ignores time stamp differences
   when the only modifications to a source file consist in
   adding/removing comments, empty lines, spaces or tabs.


/NO_GNAT_ADC

	/NO_GNAT_ADC

   Cause the compiler to ignore any configuration pragmas file GNAT.ADC in the
   default directory. Implied by qualifier /PROJECT_FILE. Often used in
   in conjunction with qualifier /CONFIGURATION_PRAGMAS_FILE.


/NOLINK

	/NOLINK

   Compile only. Do not perform binding and linking. If the root unit is
   not a main unit, this is the default.  Otherwise GNAT MAKE will
   attempt binding and linking unless all objects are up to date and the
   executable is more recent than the objects.
   This is equivalent to /ACTIONS=COMPILE

/NOLOAD

	/NOLOAD

   (this compiler qualifier is rarely used with GNAT MAKE)

   Cause the compiler to operate in semantic check mode with full
   checking for all illegalities specified in the reference manual, but
   without generation of any source code (no object or ALI file
   generated).

   Since dependent files must be accessed, you must follow the GNAT
   semantic restrictions on file structuring to operate in this mode:

   o The needed source files must be accessible.
   o Each file must contain only one compilation unit.
   o The file name and unit name must match.

   The output consists of error messages as appropriate. No object file
   or ALI file is generated. The checking corresponds exactly to the
   notion of legality in the Ada reference manual.

   Any unit can be compiled in semantics-checking-only mode, including
   units that would not normally be compiled (generic library units,
   subunits, and specifications where a separate body is present).


/NOMAIN

	/NOMAIN

   No main subprogram. Bind and link the program even if the unit name
   given on the command line is a package name. The resulting executable
   will execute the elaboration routines of the package and its closure,
   then the finalization routines.

/NOSTD_INCLUDES

	/NOSTD_INCLUDES

    Do not look for sources the in the system default directory.


/NOSTD_LIBRARIES

	/NOSTD_LIBRARIES

    Do not look for library files in the system default directory.


/OBJECT_SEARCH

	/OBJECT_SEARCH=(directory[,...])

   When looking for library and object files look also in the specified
   directories.


/OPTIMIZE

	/NOOPTIMIZE (D)
	/OPTIMIZE[=(keyword[,...])]

   Selects the level of optimization for your program.  The supported
   keywords are as follows:

	ALL (D)		Perform most optimizations, including those that
			may be expensive.

	NONE		Do not do any optimizations.  Same as /NOOPTIMIZE.

	SOME            Perform some optimizations, but omit ones that
			are costly.

	DEVELOPMENT	Same as SOME.

	INLINING	Full optimization, and also attempt automatic inlining
			of small subprograms within a unit

	UNROLL_LOOPS	Try to unroll loops.  This keyword may be specified
			with any keyword above other than NONE.  Loop
			unrolling usually, but not always, improves the
			performance of programs.


/PROJECT_FILE

	/PROJECT_FILE=filename

   Specifies the main project file to be used. The project files rooted
   at the main project file will be parsed before any other processing to
   set the building environment.


/PROCESSES

	/NOPROCESSES (D)
	/PROCESSES=NNN

   Use NNN processes to carry out the (re)complations. If you have a
   multiprocessor machine, compilations will occur in parallel.  In the
   event of compilation errors, messages from various compilations might
   get interspersed (but GNAT MAKE will give you the full ordered list of
   failing compiles at the end). This can at times be annoying.  To get a
   clean list of error messages don't use this qualifier.


/QUIET

	/NOQUIET (D)
	/QUIET

   When this qualifiers is specified, the commands carried out by GNAT
   MAKE are not displayed.


/REASONS

	/NOREASONS (D)
	/REASONS

   Displays the reason for all recompilations GNAT MAKE decides are
   necessary.


/REPORT_ERRORS

	/REPORT_ERRORS[=(keyword[,...])]
	/NOREPORT_ERRORS

   Change the way errors are reported.  The following keywords are
   supported:

	VERBOSE (D)	Verbose mode. Full error output with source lines
			to SYS$OUTPUT.

	BRIEF		Generate the brief format error messages to
			SYS$OUTPUT as well as the verbose format message or
			full listing.

	FULL		Normally, the compiler suppresses error messages that
			are likely to be redundant. This keyword causes all
			error messages to be generated. One particular effect
			is for the case of references to undefined variables.
			If a given variable is referenced several times, the
			normal format of messages produces one error.  With
			FULL, each undefined reference produces a separate
			error message.

	IMMEDIATE	Normally, the compiler saves up error messages and
			generates them at the end of compilation in proper
			sequence.  This keyword causes error messages to be
			generated as soon as they are detected. The use of
			IMMEDIATE usually causes error messages to be
			generated out of sequence. Use it when the compiler
			blows up due to an internal error.  In this case, the
			error messages may be lost. Sometimes blowups are
			the result of mishandled error messages, so you may
			want to run with this keyword to determine whether
			any error messages were generated.

	DEFAULT         Turn off VERBOSE and BRIEF.  Same as /NOREPORT_ERRORS.


/REPRESENTATION_INFO

	/NOREPRESENTATION_INFO (D)
	/REPRESENTATION_INFO[=(keyword[,...])]

   This qualifier controls output from the compiler of a listing showing
   representation information for declared types and objects.

	ARRAYS (D)	Size and alignment information is listed for
			declared array and record types.

	NONE		no information is output (equivalent to omitting
			the /REPRESENTATION_INFO qualifiers).

	OBJECTS		Size and alignment information is listed for all
			declared types and objects.

	SYMBOLIC	Symbolic expression information for values that
			are computed at run time for variant records.

	DEFAULT		Equivalent to ARRAYS.


/RUNTIME_SYSTEM

	/RUNTIME_SYSTEM=xxx

    Build against an alternate runtime system named xxx or RTS-xxx.


/SEARCH

	/SEARCH=(directory[,...])

   Search the specified directories for both source and object files.


/SKIP_MISSING

	/SKIP_MISSING=(directory[,...])

   Skip missing library sources if ALI in 'directory'.


/SOURCE_SEARCH

	/SOURCE_SEARCH=(directory[,...])

   When looking for source files also look in the specified directories.


/STYLE_CHECKS

	/NOSTYLE_CHECKS (D)
	/STYLE_CHECKS[=(keyword,[...])]

   Normally, GNAT permits any code layout consistent with the reference
   manual requirements.  This qualifier imposes style checking on the
   input source code.  The following keywords are supported:

	ALL_BUILTIN (D)		Equivalent to the following list of options:
				3, ATTRIBUTE, BLANKS, COMMENTS, END, VTABS,
				HTABS, IF_THEN, KEYWORD, LAYOUT, LINE_LENGTH,
				PRAGMA, REFERENCES, SPECS, TOKEN.

	1 .. 9			Specify indentation level from 1 to 9.
				The general style of required indentation is as
				specified by the examples in the Ada Reference
				Manual. Full line comments must be aligned with
				the -- starting on a column that is a multiple
				of the alignment level.

	ATTRIBUTE		Check attribute casing.
				Attribute names, including the case of keywords
				such as digits used as attributes names,
				must be written in mixed case, that is,
				the initial letter and any letter following an
				underscore must be uppercase.
				All other letters must be lowercase.

	BLANKS			Blanks not allowed at statement end.
				Trailing blanks are not allowed at the end of
				statements. The purpose of this rule, together
				with option HTABS (no horizontal tabs), is to
				enforce a canonical format for the use of
				blanks to separate source tokens.

	COMMENTS		Check comments.
				Comments must meet the following set of rules:

				  * The "--" that starts the column must either
				    start in column one, or else at least one
				    blank must precede this sequence.

				  * Comments that follow other tokens on a line
				    must have at least one blank following the
				    "--" at the start of the comment.

				  * Full line comments must have two blanks
				    following the "--" that starts the comment,
				    with the following exceptions.

				  * A line consisting only of the "--"
				    characters, possibly preceded by blanks is
				    permitted.

				  * A comment starting with "--x" where x is
				    a special character is permitted. This
				    allows proper processing of the output
				    generated by specialized tools including
				    gnatprep (where --! is used) and the SPARK
				    annnotation language (where --# is used).
				    For the purposes of this rule, a special
				    character is defined as being in one of the
				    ASCII ranges 16#21#..16#2F# or
				    16#3A#..16#3F#.

				  * A line consisting entirely of minus signs,
				    possibly preceded by blanks, is permitted.
				    This allows the construction of box
				    comments where lines of minus signs are
				    used to form the top and bottom of the box.

				  * If a comment starts and ends with "--" is
				    permitted as long as at least one blank
				    follows the initial "--". Together with
				    the preceding rule, this allows the
				    construction of box comments, as shown in
				    the following example:
           

				---------------------------
				-- This is a box comment --
				-- with two text lines.  --
				---------------------------

	END			Check end/exit labels.
				Optional labels on end statements ending
				subprograms and on exit statements exiting
				named loops, are required to be present.

	GNAT			Enforces a set of style conventions that
				correspond to the style used in the GNAT
				source code.  All compiler units are always
				compile with this keyword specified.

				You can find the full documentation for the
				style conventions imposed by this keyword
				in the body of the package "Style" in the
				compiler sources.

				You should not normally use this keyword.
				However, you MUST use it for compiling any
				language-defined unit, or for adding children
				to any language-defined unit other than
				"Standard".

	HTABS			No horizontal tabs.
				Horizontal tab characters are not permitted in
				the source text. Together with the BLANKS
				(no blanks at end of line) option, this
				enforces a canonical form for the use of blanks
				to separate source tokens.

	IF_THEN			Check if-then layout.
				The keyword then must appear either on the
				same line as the corresponding if, or on a line
				on its own, lined up under the if with at least
				one non-blank line in between containing all or
				part of the condition to be tested.

	KEYWORD			Check keyword casing.
				All keywords must be in lower case (with the
				exception of keywords such as digits used as
				attribute names to which this check does not
				apply).

	LAYOUT			Check layout.
				Layout of statement and declaration constructs
				must follow the recommendations in the Ada
				Reference Manual, as indicated by the form of
				the syntax rules. For example an else keyword
				must be lined up with the corresponding if
				keyword.

				There are two respects in which the style rule
				enforced by this check option are more liberal
				than those in the Ada Reference Manual.
				First in the case of record declarations,
				it is permissible to put the record keyword on
				the same line as the type keyword, and then
				the end in end record must line up under type.
				For example, either of the following two
				layouts is acceptable:

				type q is record
				   a : integer;
				   b : integer;
				end record;

				type q is
				   record
				      a : integer;
				      b : integer;
				   end record;

				Second, in the case of a block statement,
				a permitted alternative is to put the block
				label on the same line as the declare or begin
				keyword, and then line the end keyword up under
				the block label. For example both the following
				are permitted:

     

				Block : declare
				   A : Integer := 3;
				begin
				   Proc (A, A);
				end Block;

				Block :
				   declare
				      A : Integer := 3;
				   begin
				      Proc (A, A);
				   end Block;

				The same alternative format is allowed for
				loops. For example, both of the following are
				permitted:

     

				Clear : while J < 10 loop
				   A (J) := 0;
				end loop Clear;

				Clear :
				   while J < 10 loop
				      A (J) := 0;
				   end loop Clear;



	LINE_LENGTH		Check maximum line length.
				The length of source lines must not exceed 79
				characters, including any trailing blanks
				The value of 79 allows convenient display on
				an 80 character wide device or window, allowing
				for possible special treatment of 80 character
				lines.

	ORDERED_SUBPROGRAMS	Check order of subprogram bodies.
				All subprogram bodies in a given scope (e.g.
				a package body) must be in alphabetical order.
				The ordering rule uses normal Ada rules for
				comparing strings, ignoring casing of letters,
				except that if there is a trailing numeric
				suffix, then the value of this suffix is used
				in the ordering (e.g. Junk2 comes before
				Junk10).

	NONE			The default behavior.  Same as /NOSTYLE_CHECKS.

	PRAGMA			Check pragma casing.
				Pragma names must be written in mixed case,
				that is, the initial letter and any letter
				following an underscore must be uppercase.
				All other letters must be lowercase.

	REFERENCES		Check references.
				All identifier references must be cased in the
				same way as the corresponding declaration.
				No specific casing style is imposed on
				identifiers. The only requirement is for
				consistency of references with declarations.

	RM_COLUMN_LAYOUT	Enforce the layout conventions suggested by
				the examples and syntax rules of the Ada
				Language Reference Manual. For example, an
				"else" must line up with an "if" and code in
				the "then" and "else" parts must be indented.
				The compiler considers violations of the
				layout rules a syntax error if you specify
				this keyword.

	SPECS			Check separate specs.
				Separate declarations ("specs") are required
				for subprograms (a body is not allowed to serve
				as its own declaration). The only exception is
				that parameterless library level procedures are
				not required to have a separate declaration.
				This exception covers the most frequent form of
				main program procedures.

	STANDARD_CASING		Check casing of entities in Standard.
				Any identifier from Standard must be cased to
				match the presentation in the Ada Reference
				Manual (for example, Integer and ASCII.NUL).

	TOKEN			Check token spacing.
				The following token spacing rules are enforced:

				  * The keywords abs and not must be followed
				    by a space.

				  * The token => must be surrounded by spaces.

				  * The token <> must be preceded by a space or
				    a left parenthesis.

				  * Binary operators other than ** must be
				    surrounded by spaces. There is no
				    restriction on the layout of the ** binary
				    operator.

 				  * Colon must be surrounded by spaces.

				  * Colon-equal (assignment) must be surrounded
				    by spaces.

				  * Comma must be the first non-blank character
				    on the line, or be immediately preceded by
				    a non-blank character, and must be followed
				    by a space.

				  * If the token preceding a left paren ends
				    with a letter or digit, then a space must
				    separate the two tokens.

				  * A right parenthesis must either be the
				    first non-blank character on a line, or it
				    must be preceded by a non-blank character.

				  * A semicolon must not be preceded by
				    a space, and must not be followed by
				    a non-blank character.

				  * A unary plus or minus may not be followed
				    by a space.

				  * A vertical bar must be surrounded by
				    spaces.

				In the above rules, appearing in column one is
				always permitted, that is, counts as meeting
				either a requirement for a required preceding
				space, or as meeting a requirement for no
				preceding space.

				Appearing at the end of a line is also always
				permitted, that is, counts as meeting either
				a requirement for a following space,
				or as meeting a requirement for no following
				space.

	VTABS			No form feeds or vertical tabs.
				Form feeds or vertical tab characters are not
				permitted in the source text.


/SWITCH_CHECK

	/NOSWITCH_CHECK (D)
	/SWITCH_CHECK

  Recompile if compiler switches have changed since last compilation.
  All compiler switches but -I and -o are taken into account in the
  following way: orders between different "first letter" switches are ignored,
  but orders between same switches are taken into account. For example,
  -O -O2 is different than -O2 -O, but -g -O is equivalent to -O -g.


/SYNTAX_ONLY

	/NOSYNTAX_ONLY (D)
	/SYNTAX_ONLY

   (this compiler qualifier is rarely used with GNAT MAKE)

   Run GNAT in syntax checking only mode.  You can check a series of
   files in a single command, and can use wild cards to specify such a
   group of files.

   You may use other qualifiers in conjunction with this qualifier. In
   particular, /LIST and /REPORT_ERRORS=VERBOSE are useful to control the
   format of any generated error messages.

   The output is simply the error messages, if any. No object file or ALI
   file is generated by a syntax-only compilation. Also, no units other
   than the one specified are accessed. For example, if a unit "X" with's
   a unit "Y", compiling unit "X" in syntax check only mode does not
   access the source file containing unit "Y".

   Normally, GNAT allows only a single unit in a source file. However,
   this restriction does not apply in syntax-check-only mode, and it is
   possible to check a file containing multiple compilation units
   concatenated together. This is primarily used by the GNAT CHOP
   command.


/TRACE_UNITS

	/TRACE_UNITS
	/NOTRACE_UNITS

   This switch that does for the frontend what /VERBOSE does for the
   backend. The system prints the name of each unit, either a compilation
   unit or nested unit, as it is being analyzed.


/TREE_OUTPUT

	/TREE_OUTPUT
	/NOTREE_OUTPUT

   Cause GNAT to write the internal tree for a unit to a file (with the
   filetype ATB for a body or ATS for a spec).  This is not normally
   required, but is used by separate analysis tools. Typically these
   tools do the necessary compilations automatically, so you should never
   have to specify this switch in normal operation.


/TRY_SEMANTICS

	/TRY_SEMANTICS
	/NOTRY_SEMANTICS

   In normal operation mode the compiler first parses the program and
   determines if there are any syntax errors. If there are, appropriate
   error messages are generated and compilation is immediately
   terminated.  This qualifier tells GNAT to continue with semantic
   analysis even if syntax errors have been found.  This may enable the
   detection of more errors in a single run. On the other hand, the
   semantic analyzer is more likely to encounter some internal fatal
   error when given a syntactically invalid tree.


/UNIQUE

	/NOUNIQUE (D)
	/UNIQUE

  Recompile at most the main file. It implies /ACTIONS=COMPILE.
  Combined with /FORCE_COMPILE, it is equivalent to calling the compiler
  directly.


/UNIQUE_ERROR_TAG

	/NOUNIQUE_ERROR_TAG (D)
	/UNIQUE_ERROR_TAG

   Tag compiler error messages with the string "error: ".

   (Warning: for GNAT MAKE, this compiler qualifier cannot be abbreviated
    shorter than /UNIQUE_, because of the existence of GNAT MAKE qualifier
    /UNIQUE) 


/UNITS_LIST

	/NOUNITS_LIST (D)
	/UNITS_LIST

   Print a list of units required by this compilation on SYS$OUTPUT.  The
   listing includes all units on which the unit being compiled depends
   either directly or indirectly.


/UPPERCASE_EXTERNALS

	/NOUPPERCASE_EXTERNALS (D)
	/UPPERCASE_EXTERNALS

   Fold default and explicit external names in pragmas Import and Export
   to uppercase for compatibility with the default behavior of DEC C.


/VALIDITY_CHECKING

	/VALIDITY_CHECKING[=(keyword,[...])]

   Control level of validity checking.

	DEFAULT (D)     In this mode checks are made to prevent
			erroneous behavior in accordance with the RM.
			Notably extra checks may be needed for case
			statements and subscripted array assignments.

	NONE		No special checks for invalid values are
			performed. This means that references to
			uninitialized variables can cause erroneous
			behavior from constructs like case statements
			and subscripted array assignments. In this
			mode, invalid values can lead to erroneous
			behavior.

	FULL		Every assignment is checked for validity, so
			that it is impossible to assign invalid values.
			The RM specifically allows such assignments,
			but in this mode, invalid values can never be
			assigned, and an attempt to perform such an
			assignment immediately raises Constraint_Error.
			This behavior is allowed (but not required) by
			the RM. This mode is intended as a debugging aid,
			and may be useful in helping to track down
			uninitialized variables. It may be useful to
			use this in conjunction with the Normalize_Scalars
			pragma which attempts to initialize with invalid
			values where possible.


/VERBOSE

	/NOVERBOSE (D)
	/VERBOSE

   Displays the reason for all recompilations GNAT MAKE decides are
   necessary.


/WARNINGS

	/NOWARNINGS

   Suppress the output of all warning messages from the GNAT front end.
   Note that it does not suppress warnings from the gcc back end. 

	/WARNINGS[=(keyword[,...])]

   In addition to error messages, corresponding to illegalities as
   defined in the reference manual, the compiler detects two kinds of
   warning situations.  First, the compiler considers some constructs
   suspicious and generates a warning message to alert you to a possible
   error. Second, if the compiler detects a situation that is sure to
   raise an exception at runtime, it generates a warning message.

   You may specify the following keywords to change this behavior:

	DEFAULT (D) 		The default behavior above.

	ALL			Activate all optional warnings.
				Activates most optional warning messages, see
				remaining list in this section for details on
				optional warning messages that can be
				individually controlled. The warnings that are
				not turned on by this option are
				BIASED_ROUNDING, IMPLICIT_DEREFERENCE, HIDING
				and ELABORATION. All other optional Ada
				warnings are turned on.

	NOALL			Suppress all optional errors.
				Suppresses all optional warning messages that
				can be activated by option ALL.

	ALL_GCC			Request additional messages from the GCC
				backend.  Most of these are not relevant
				to Ada.

	BIASED_ROUNDING		Activate warnings on biased rounding.
				If a static floating-point expression has
				a value that is exactly half way between two
				adjacent machine numbers, then the rules of Ada
				(Ada Reference Manual, section 4.9(38)) require
				that this rounding be done away from zero, even
				if the normal unbiased rounding rules at run
				time would require rounding towards zero.

				This warning message alerts you to such
				instances where compile-time rounding and
				run-time rounding are not equivalent. If it is
				important to get proper run-time rounding,
				then you can force this by making one of the
				operands into a variable. The default is that
				such warnings are not generated. Note that
				/WARNINGS=ALL does not affect the setting of
				this warning option.

	NOBIASED_ROUNDING	Suppress warnings on biased rounding.
				Disable warnings on biased rounding.

	CONDITIONALS		Activate warnings for conditional
				Expressions used in tests that are known
				to be True or False at compile time. The
				default is that such warnings are not
				generated.

	NOCONDITIONALS		Suppress warnings for conditional
				expressions used in tests that are known
				to be True or False at compile time.

	IMPLICIT_DEREFERENCE	Activate warnings on implicit dereferencing.
				The use of a prefix of an access type in an
				indexed component, slice, or selected component
				without an explicit .all will generate
				a warning. With this warning enabled, access
				checks occur only at points where an explicit
				.all appears in the source code (assuming no
				warnings are generated as a result of this
				option). The default is that such warnings are
				not generated. Note that /WARNINGS=ALL does not
				affect the setting of this warning option.

	NOIMPLICIT_DEREFERENCE	Suppress warnings on implicit dereferencing.
				in indexed components, slices, and selected
				components.

	ELABORATION		Activate warnings on missing pragma
				Elaborate_All statements. The default is
				that such warnings are not generated.

	NOELABORATION		Suppress warnings on missing pragma
				Elaborate_All statements.

	ERRORS			Warning messages are to be treated as errors.
				The warning string still appears, but the
				warning messages are counted as errors, and
				prevent the generation of an object file.

	HIDING			Activate warnings on hiding declarations.
				A declaration is considered hiding if it is
				for a non-overloadable entity, and it declares
				an entity with the same name as some other
				entity that is directly or use-visible. The
				default is that such warnings are not
				generated.

	NOHIDING		Suppress warnings on hiding declarations.

	IMPLEMENTATION		Activate warnings for a with of an internal
				GNAT implementation unit, defined as any unit
				from the Ada, Interfaces, GNAT, DEC or
				System hierarchies that is not documented in
				either the Ada Reference Manual or the GNAT
				Programmer's Reference Manual. Such units are
				intended only for internal implementation
				purposes and should not be with'ed by user
				programs. The default is that such warnings
		 		are generated.

	NOIMPLEMENTATION	Disables warnings for a with of an internal
				GNAT implementation unit.

	INEFFECTIVE_INLINE	Activate warnings on ineffective pragma Inlines
				Activates warnings for failure of front end
				inlining (activated by /INLINE=FULL) to inline
				a particular call. There are many reasons for
				not being able to inline a call, including most
				commonly that the call is too complex to
				inline. This warning can also be turned on
				using /INLINE=FULL.

	NOINEFFECTIVE_INLINE	Suppress warnings on ineffective pragma Inlines
				Suppresses warnings on ineffective pragma
				Inlines. If the inlining mechanism cannot
				inline a call, it will simply ignore the
				request silently.

	OPTIONAL		Activate all optional warning messages.
				See other options under this qualifier
				for details on optional warning messages
				that can be individually controlled. The
				one exception is that /WARNINGS=OPTIONAL
				doesn't activate warnings for hiding
				variables (/WARNINGS=HIDING), so if this
				warning is required it must be explicitly
				set.

	NOOPTIONAL		Suppress all optional warning messages.
				See other options under this qualifier
				for details on optional warning messages
				that can be individually controlled.

	OVERLAYS		Activate warnings for possibly unintended
				initialization effects of defining address
				clauses that cause one variable to overlap
				another. The default is that such warnings
				are generated.

	NOOVERLAYS		Suppress warnings on possibly unintended
				initialization effects of defining address
				clauses that cause one variable to overlap
				another.

	REDUNDANT		Activate warnings for redundant constructs.
				In particular assignments of a variable to
				itself, and a type conversion that converts
				an object to its own type. The default
				is that such warnings are not generated.

	NOREDUNDANT		Suppress warnings for redundant constructs.

	SUPPRESS		Completely suppresse the output of all warning
				messages.  Same as /NOWARNINGS.

	UNINITIALIZED		Generate warnings for uninitialized variables.
				This is a GCC option, not an Ada option.
				You must also specify the /OPTIMIZE qualifier
				with a value other than NONE (in other words,
				this keyword works only if optimization is
				turned on).

	UNREFERENCED_FORMALS	Activate warnings on unreferenced formals.
				Causes a warning to be generated if a formal
				parameter is not referenced in the body of
				the subprogram. This warning can also be turned
				on using option ALL or UNUSED.

	NOUNREFERENCED_FORMALS	Suppress warnings on unreferenced formals.
				Suppresses warnings for unreferenced formal
				parameters. Note that the combination UNUSED
				followed by NOUNREFERENCED_FORMALS has the
				effect of warning on unreferenced entities
				other than subprogram formals.

	UNUSED			Activates warnings to be generated for entities
				that are defined but not referenced, and for
				units that are with'ed and not referenced. In
				the case of packages, a warning is also
			 	generated if no entities in the package are
				referenced. This means that if the package
				is referenced but the only references are in
				use clauses or renames declarations, a warning
				is still generated. A warning is also generated
				for a generic package that is with'ed but never
				instantiated.  In the case where a package or
				subprogram body is compiled, and there is a
				with on the corresponding spec that is only
			 	referenced in the body, a warning is also
				generated, noting that the with can be moved
				to the body. The default is that such warnings
				are not generated.

	NOUNUSED		Suppress warnings for unused entities and
				packages.


/WIDE_CHARACTER_ENCODING

	/NOWIDE_CHARACTER_ENCODING (D)
	/WIDE_CHARACTER_ENCODING[=encode-type]

   Specifies the mechanism used to encode wide characters.  'encode-type'
   is one of the following:

	BRACKETS (D)	A wide character is encoded as ["xxxx"] where XXXX
			are four hexadecimal digits representing the coding
			('Pos value) of the character in type
			Wide_Character. The hexadecimal digits may use upper
			or lower case letters.

			This notation can also be used for upper half
			Character values using the format ["xx"] where XX is
			two hexadecimal digits representing the coding ('Pos
			value) of the character in type Character (or
			Wide_Character). The hexadecimal digits may use upper
			of lower case.

	NONE		No wide characters are allowed.  Same
			as /NOWIDE_CHARCTER_ENCODING.

	HEX		In this encoding, a wide character is represented by
			the following five character sequence: ESC a b c d
			Where 'a', 'b', 'c', and 'd' are the four hexadecimal
			characters (using uppercase letters) of the wide
			character code. For example, ESC A345 is used to
			represent the wide character with code 16#A345#. This
			scheme is compatible with use of the full
			Wide_Character set.

	UPPER		The wide character with encoding 16#abcd# where the
			upper bit is on (in other words, "a" is in the range
			8-F) is represented as two bytes, 16#ab# and 16#cd#.
			The second byte may never be a format control
			character, but is not required to be in the upper
			half. This method can be also used for shift-JIS or
			EUC, where the internal coding matches the external
			coding.

	SHIFT_JIS	A wide character is represented by a two-character
			sequence, 16#ab# and 16#cd#, with the restrictions
			described for upper-half encoding as described above.
			The internal character code is the corresponding JIS
			character according to the standard algorithm for
			Shift-JIS conversion. Only characters defined in the
			JIS code set table can be used with this encoding
			method.

	UTF8		A wide character is represented using
			UCS Transformation Format 8 (UTF-8) as defined in Annex
			R of ISO 10646-1/Am.2.  Depending on the character
			value, the representation is a one, two, or three byte
			sequence:

			16#0000#-16#007f#: 2#0xxxxxxx#
			16#0080#-16#07ff#: 2#110xxxxx# 2#10xxxxxx#
			16#0800#-16#ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#

			where the xxx bits correspond to the left-padded bits
			of the the 16-bit character value. Note that all lower
			half ASCII characters are represented as ASCII bytes
			and all upper half characters and other wide characters
			are represented as sequences of upper-half (The full
			UTF-8 scheme allows for encoding 31-bit characters as
			6-byte sequences, but in this implementation, all UTF-8
			sequences of four or more bytes length will be treated
			as illegal).

	EUC		A wide character is represented by a two-character
			sequence 16#ab# and 16#cd#, with both characters being
			in the upper half. The internal character code is the
			corresponding JIS character according to the EUC
			encoding algorithm. Only characters defined in the JIS
			code set table can be used with this encoding method.


/XDEBUG

	/NOXDEBUG (D)
	/XDEBUG

   Output expanded source files for source level debugging.
   The expanded source (see /EXPAND_SOURCE) is written to files
   with names formed by appending "_DG" to the input file name,
   The debugging information generated by the /DEBUG qualifier will then
   refer to the generated file. This allows source level debugging using
   the generated code which is sometimes useful for complex code, for example
   to find out exactly which part of a complex construction raised an
   exception.


/XREF

	/XREF[=keyword]

   Normally the compiler generates full cross-referencing information in
   the .ALI file. This information is used by a number of tools,
   including GNAT FIND and GNAT XREF.

	GENERATE (D)		Generate cross-referencing information.

        SUPPRESS		Suppress cross-referencing information.
				This saves some space and may slightly
				speed up compilation, but means that some
				tools cannot be used.


3  Notes

   Please note the following:

   o If you enter "$ GNAT MAKE file.ADB", where file.ADB is a subunit or
     body of a generic unit, GNAT MAKE recompiles file.ADB (because it
     finds no ALI) and stops, issuing a warning.

   o GNAT MAKE does not examine OBJ files, only ALI files.  Deleting OBJ
     files will not force a recompile. You can force everything to be
     recompiled either by deleting the ALI files or by using the
     /FORCE_COMPILE qualifier.

   o If GNAT MAKE finds no ALI files, it recompiles the main program and
     all other units required by the main program. Thus GNAT MAKE can be
     used for the initial compile, as well as during the re-edit
     development cycle.


3  How_It_Works

   Generally GNAT MAKE automatically performs all necessary
   recompilations and you don't need to worry about how it works.
   However, it may be useful to have some basic understanding of the GNAT
   MAKE approach and in particular to understand how it uses the results
   of previous compilations without incorrectly depending on them.

   First a definition: an object file is considered "up to date" if the
   corresponding ALI file exists and if all the source files listed in
   the dependency section of this ALI file have time stamps matching
   those in the ALI file. This means that neither the source file itself
   nor any files that it depends on have been modified, and hence there
   is no need to recompile this file.

   GNAT MAKE works by first checking if the specified main program is up
   to date. If so, it is done, and no compilations are required. If not,
   it compiles the main program to build a new ALI file that reflects the
   latest sources. It examines this ALI file to find all the source files
   on which the main program depends, and recursively applies the
   up-to-date test on all these files.

   This process ensures that GNAT MAKE only trusts the dependencies in an
   existing ALI file if they are known to be correct.  Otherwise it
   always recompiles to determine a new, guaranteed accurate set of
   dependencies. Thus the program is compiled "upside down" from what may
   be more familiar as the required order of compilation in some other
   Ada systems. In particular, clients are compiled before the units on
   which they depend. The ability of GNAT to compile in any order is
   critical in allowing an order of compilation to be chosen that
   guarantees that GNAT MAKE will recompute a correct set of new
   dependencies if necessary.


3  Examples

	$ GNAT MAKE HELLO.ADB

   Compile all files necessary to bind and link the main program
   HELLO.ADB (containing unit "Hello") and bind and link the resulting
   object files to generate an executable file HELLO.EXE.

	$ GNAT MAKE /QUIT Main_Unit -
	    /COMPILER_SWITCHES /OPTIMIZE=ALL -
	    /BINDER_SWITCHES /ORDER_OF_ELABORATION

   Compile all files necessary to bind and link the main program unit
   "Main_Unit" (from file MAIN_UNIT.ADB). All compilations will be done
   with all optimizations and the order of elaboration will be listed by
   the binder. GNAT MAKE will operate in quiet mode, not displaying
   commands it is executing.


2  PREPROCESS

   This program provides a simple preprocessing capability for Ada
   programs.  It is designed for use with GNAT, but is not dependent on
   any special features of GNAT.

   Format:
      GNAT PREPROCESS input-file output-file def-file


3  Parameters

infile-file

   The name of the input file, which is an Ada source file containing
   preprocessor directives.  See "Input_Format" for the format of
   this file.


output-file

   The name of the output file, which is an Ada source in standard Ada
   form. When used with GNAT, this file name will normally have an ADS or
   ADB filetype.


def-file

   The name of a text file containing definitions of
   symbols to be referenced by the preprocessor.

   It contains lines of the form

     symbol := value

   where 'symbol' is an identifier, following normal Ada
   (case-insensitive) rules for its syntax, and 'value' is one of
   the following:

   o Empty, corresponding to a null substitution.

   o A string literal using normal Ada syntax.

   o Any sequence of characters from the set (letters, digits, period,
     underline).

   Comment lines may also appear in the definitions file, starting with
   the usual --, and comments may be added to the definitions lines.


3  Input_Format

   The input text may contain preprocessor conditional inclusion lines,
   and also general symbol substitution sequences.

   The preprocessor conditional inclusion commands have the form

    #if [not] symbol [then]
       lines
    #elsif [not] symbol [then]
       lines
    #elsif [not] symbol [then]
       lines
    ...
    #else
       lines
    #end if;

   For these Boolean tests, the symbol must have either the value True or
   False. If the value is True, then the corresponding lines are included,
   and if the value is False, they are excluded. It is an error to
   reference a symbol not defined in the symbol definitions file, or
   to reference a symbol that has a value other than True or False.

   The use of the not operator inverts the sense of this logical test, so
   that the lines are included only if the symbol is not defined.

   The THEN keyword is optional as shown

   The # must be in column one, but otherwise the format is free form.
   Spaces or tabs may appear between the # and the keyword. The keywords
   and the symbols are case insensitive as in normal Ada code. Comments
   may be used on a preprocessor line, but other than that, no other
   tokens may appear on a preprocessor line.

   Any number of #elsif clauses can be present, including none at all.

   The #else is optional, as in Ada.

   Symbol substitution is obtained by using the sequence

   $symbol

   anywhere within a source line, except in a comment. The identifier
   following the $ must match one of the symbols defined in the symbol
   definition file, and the result is to substitute the value of the
   symbol in place of $symbol in the output file.


3  Qualifiers

/ASSOCIATE

	/ASSOCIATE="name=val"

   Defines a new symbol, associated with value. If no value is given
   on the command line, then symbol is considered to be True.
   This qualifier can be used in place of a definition file.


/BLANK_LINES

	/NOBLANK_LINES (D)
	/BLANK_LINES

   Causes both preprocessor lines and the lines deleted by preprocessing
   to be replaced by blank lines in the output source file, thus
   preserving line numbers in the output file.


/COMMENTS

	/NOCOMMENTS (D)
	/COMMENTS

   /COMMENTS causes both preprocessor lines and the lines deleted
   by preprocessing to be retained in the output source as comments marked
   with the special string "--! ". This option will result in line numbers
   being preserved in the output file.

   /NOCOMMENTS causes both preprocessor lines and the lines deleted by
   preprocessing to be replaced by blank lines in the output source file,
   thus preserving line numbers in the output file.


/REFERENCE

	/NOREFERENCE (D)
	/REFERENCE

   Causes a "Source_Reference" pragma to be generated that references the
   original input file, so that error messages will use the file name of
   this original file.  Also implies /BLANK_LINES if /COMMENTS is not
   specified.


/REMOVE

	/REMOVE (D)
	/NOREMOVE

   Preprocessor lines and deleted lines are completely removed from the
   output.


/SYMBOLS

	/NOSYMBOLS (D)
	/SYMBOLS

   Causes a sorted list of symbol names and values to be listed on
   SYS$OUTPUT.


/UNDEFINED

	/NOUNDEFINED (D)
	/UNDEFINED


2  PRETTY

   The GNAT pretty-printer. GNAT PRETTY takes a compilable Ada source as input 
   and generates the reformatted version of the source as output. Different 
   formatting styles can be specified by means of qualifiers. 

   As a part of its processing, GNAT PRETTY has to compile the argument source.
   Therefore, only legal Ada sources can be reformatted by GNAT PRETTY.
   Moreover, if the argument source depends semantically upon units located
   outside the current directory, the corresponding search path should be
   provided by appropriate qualifiers. 


3  Parameters

filename 

   The name of the source file to reformat. May contain directory information.

   By default GNAT PRETTY puts the formatted source into the file which name
   is obtained by appending the '.PP' suffix to the name of the argument file
   (if the file with this name already exists, it is unconditionally
    overridden). The output can be directed to a specific file or to the
   standard output, using proper qualifiers. All diagnostic information is
   sent to the standard error. 

   GNAT PRETTY needs the tree file created for the argument source file. If 
   possible, it reuses the existing tree file, otherwise it creates it by 
   compiling the argument source (that is why GNAT PRETTY may need /SEARCH
   qualifiers to define the source search path for this compilation).
   If GNAT PRETTY creates the tree file, it removes it at the end if its run.
   If the ALI file was created together with the tree file, it is also removed,
   but if the ALI file existed before creation the tree file and is it was not
   overridden as a part of creating the tree, GNAT PRETTY does not remove this
   ALI file. 

3  Qualifiers

/ALIGN

	/ALIGN[=align-option, align-option, ...]

   Set alignments. By default, all alignments (colons in declarations,
   initialisations in declarations, assignments and arrow delimiters) are ON.
   align-option may be one of the following:

      OFF (D)      Set all alignments to OFF
      COLONS       Set alignments of colons in declarations to ON
      DECLARATIONS Set alignments of initialisations in declarations to ON
      STATEMENTS   Set alignments of assignments statements to ON
      ARROWS       Set alignments of arrow delimiters to ON.

   Specifying one of the ON options without first specifying the OFF option
   has no effect, because by default all alignments are set to ON.


/ATTRIBUTE_CASING

	/ATTRIBUTE_CASING[=casing-option]

   Set the case of the attributes. By default the attributes are in mixed case.
   casing-option may be one of the following:

      MIXED_CASE (D)
      LOWER_CASE
      UPPER_CASE


/COMMENTS_LAYOUT

	/COMMENTS_LAYOUT[=layout-option, layout-option, ...]

   Set the comment layout. By default, comments use the GNAT style comment
   line indentation.
   layout-option may be one of the following:

     DEFAULT (D)         GNAT style comment line indentation
     STANDARD_INDENT     Standard comment line indentation
     GNAT_BEGINNING      GNAT style comment beginning
     REFORMAT            Reformat comment blocks

     All combinations of layout options are allowed, except for DEFAULT and
     STANDARD_INDENT which are mutually exclusive.

     The difference between "GNAT style comment line indentation" and 
     "standard comment line indentation" is the following: for standard
     comment indentation, any comment line is indented as if it were
     a declaration or statement at the same place.
     For GNAT style comment indentation, comment lines which are immediately
     followed by if or case statement alternative, record variant or 'begin'
     keyword are indented as the keyword that follows them.: 

     Standard indentation: 

        if A then 
           null; 
           -- some comment 
        else 
           null; 
        end if; 

     GNAT style indentation: 

        if A then 
           null; 
        -- some comment 
        else 
           null; 
        end if; 

     Option "GNAT style comment beginning" means that for each comment which
     is not considered as non-formattable separator (that is, the comment line 
     contains only dashes, or a comment line ends with two dashes), there will
     be at least two spaces between starting "--" and the first non-blank
     character of the comment. 

/CONFIGURATION_PRAGMAS_FILE

	/CONFIGURATION_PRAGMAS_FILE=file

   Specify a configuration pragmas file that need to be passed to the compiler.


/CONSTRUCT_LAYOUT

	/CONSTRUCT_LAYOUT[=construct-option]

   Set construct layout. Default is GNAT style layout.
   construct-option may be one of the following:
 
      GNAT (D)
      COMPACT
      UNCOMPACT 
 
   The difference between GNAT style and Compact layout on one hand 
   and Uncompact layout on the other hand can be illustrated by the 
   following examples: 

       GNAT style and                          Uncompact layout 
       Compact layout 

       type q is record                        type q is 
          a : integer;                            record 
          b : integer;                               a : integer; 
       end record;                                   b : integer; 
                                                  end record; 


       Block : declare                         Block : 
          A : Integer := 3;                       declare 
       begin                                         A : Integer := 3; 
          Proc (A, A);                            begin 
       end Block;                                    Proc (A, A); 
                                                  end Block; 

       Clear : for J in 1 .. 10 loop           Clear : 
          A (J) := 0;                             for J in 1 .. 10 loop 
       end loop Clear;                               A (J) := 0; 
                                                  end loop Clear; 


   A further difference between GNAT style layout and compact layout is that
   in GNAT style layout compound statements, return statements and bodies are
   always separated by empty lines. 


/CONTINUATION_INDENT

	/CONTINUATION_INDENT=nnn

   Indentation level for continuation lines, nnn from 1 .. 9.
   The default value is one less then the (normal) indentation level, unless 
   the indentation is set to 1: in that case the default value for 
   continuation line indentation is also 1.


/EXTERNAL_REFERENCE

	/EXTERNAL_REFERENCE="name=val"

   Specifies an external reference to the project manager. Useful only if
   /PROJECT_FILE is used.

   Example:
      /EXTERNAL_REFERENCE="DEBUG=TRUE"


/FORCED_OUTPUT

	/FORCED_OUTPUT=file

   Write the output into the specified file, overriding any possibly existing 
   file.


/INDENTATION_LEVEL

	/INDENTATION_LEVEL=nnn

   Specify the number of spaces to add for each indentation level.
   nnn must be between 1 and 9. The default is 3.


/KEYWORD_CASING

	/KEYWORD_CASING[=keyword-option]

   Specify the case of Ada keywords. The default is keywords in lower case.
   keyword-option may be one of the following:

      LOWER_CASE (D)
      UPPER_CASE


/LINE_LENGTH_MAX

	/LINE_LENGTH_MAX=nnn

   Set the maximum line length, nnn from 32 ..256. The default is 79.


/MAX_INDENT

	/MAX_INDENT=nnn

   Do not use an additional indentation level for case alternatives 
   and variants if their number is nnn or more. The default is  10.
   If nnn is zero, an additional indentation level is  used for any number
   of case alternatives and variants.


/MESSAGES_PROJECT_FILE

	/MESSAGES_PROJECT_FILE[=messages-option]

   Specifies the "verbosity" of the parsing of project files.
   messages-option may be one of the following:

      DEFAULT (D)   No messages are output if there is no error or warning.

      MEDIUM        A small number of messages are output.

      HIGH          A great number of messages are output, most of them not
                    being useful for the user.


/NO_MISSED_LABELS

	/NO_MISSED_LABELS

   Do not insert missing end/exit labels. The end label is the name of 
   a construct that may optionally appear at the end of the construct. This 
   includes the names of packages and subprograms. 
   Similarly, the exit label is the name of a loop that may appear as the 
   argument of an exit statement within the loop. By default, gnatpp inserts
   these end/exit labels when they are absent in the original source.
   This qualifier /NO_MISSED_LABELS suppresses this insertion, so that the
   formatted source reflects the original.


/OUTPUT

	/OUTPUT=file

   Write the output to the specified file. If the file already exists,
   an error is reported.


/OVERRIDING_REPLACE

	/NOOVERRIDING_REPLACE (D)
	/OVERRIDING_REPLACE

   Replace the argument source with the pretty-printed source and copy the
   argument source into filename.NPP, overriding any existing file if needed.


/PRAGMA_CASING

	/PRAGMA_CASING[=pragma-option]

   Set the case of pragma identifiers. The default is Mixed case.
   pragma-option may be one of the following:

      MIXED_CASE (D)
      LOWER_CASE
      UPPER_CASE


/REPLACE

	/NOREPLACE (D)
	/REPLACE

   Replace the argument source with the pretty-printed source and copy the
   argument source into filename.NPP. If filename.NPP already exists, report
   an error and exit.


/PROJECT_FILE

	/PROJECT_FILE=filename

   Specifies the main project file to be used. The project files rooted
   at the main project file will be parsed before any other processing to
   set the building environment.


/REFERENCE_CASING

	/REFERENCE_CASING[=reference-option]

   Set the case of any reference to an identifier. The default is that each
   mention of an identifier has the same casing as its declaration 
   (as declared).
   reference-option may be one of the following:

      AS_DECLARED (D)
      MIXED


/SEARCH

	/SEARCH=(directory[,...])

    When looking for source files also look in directories specified.


/STANDARD_OUTPUT

	/NOSTANDARD_OUTPUT (D)
	/STANDARD_OUTPUT

   Redirect the output to the standard output.

2  SHARED

   Link a shareable image library by invoking the system linker with a
   correct list of object files and library references.

   Format:

     GNAT SHARED /IMAGE=new_shared_library object1 object2 ...


3  Parameters

objects-and-libraries-and-shareables-and-options

   These parameters are passed to the linker uninterpreted. They
   typically include the names of object files for units written in other
   languages than Ada and any library references required to resolve
   references in any of these foreign language units, or in "pragma
   Import" statements in any Ada units.

   Wildcard file specifications are expanded.


3  Qualifiers

/DEBUG

        /DEBUG[=debug-option]
        /NODEBUG

   Specifies the amount of debugging information included.  'debug-option'
   is one of the following:

        ALL (D)         Include full debugging information.

        NONE            Provide no debugging information.  Same as /NODEBUG.

        TRACEBACK       Provide sufficient debug information for a traceback.

        NOTRACEBACK     Same as NONE.


/IMAGE

        /IMAGE=image-name

   'image-name' specifies the name for the generated shared library.


/IDENTIFICATION

        /IDENTIFICATION="<string>"

   "<string>" specifies the string to be stored in the image file ident-
   ification field in the image header. It overrides any pragma Ident
   specified string.


/NOINHIBIT-IMAGE

        /NOINHIBIT-IMAGE

   Delete image if there are errors or warnings.


/NOSTART_FILES

        /NOSTART_FILES

   Link in default image initialization and startup functions.


/VERBOSE

        /NOVERBOSE (D)
        /VERBOSE

   Causes additional information to be output, including a full list of
   the included object files. This switch option is most useful when you
   want to see what set of object files are being used in the link step.


/<other>

        /<other>

   Any other switch transmitted to the underlying linker.


2  STANDARD

   Dynamically determines the values of all the relevant parameters in
   Standard, and prints them out in the form of an Ada source listing
   for Standard, displaying all the values of interest. This output is
   generated to SYS$OUTPUT.


2  STUB

   Creates body stubs, that is, empty but compilable bodies for library unit 
   declarations.

   To create a body stub, the tool STUB has to compile the library unit
   declaration. Therefore, bodies can be created only for legal library units.
   Moreover, if a library unit depends semantically upon units located outside
   the current directory, the source search path needs to be provided.

   Format:
      GNAT STUB [qualifiers] filespec [directory]


3  Parameters

filespec

   The name of the source file that contains a library unit declaration for
   which a body must be created. The file spec may contain the path
   information. The file spec does not have to follow the GNAT file name
   conventions. If the file spec does not follow GNAT file naming conventions,
   the name of the body file must be provided explicitly as the value of 
   qualifier /OUTPUT. If the file spec follows the GNAT file naming conventions
   and no qualifier /OUTPUT is provided, the name of the created body file is
   deducted from the argument file spec by replacing the `.ADS' suffix with
   the `.ADB' suffix.

[directory]

   Indicates the directory in which the body stub is to be placed
   (the default is the current default directory).


3  Qualifiers

/CONFIGURATION_PRAGMAS_FILE

	/CONFIGURATION_PRAGMAS_FILE=filespec

   Specifies a configuration pragmas file that must be taken into account
   when compiling.


/CURRENT_DIRECTORY

	/CURRENT_DIRECTORY (D)
	/NOCURRENT_DIRECTORY

   Look for source, library or object files in the default directory.

/EXTERNAL_REFERENCE

	/EXTERNAL_REFERENCE="name=val"

   Specifies an external reference to the project manager. Useful only if
   /PROJECT_FILE is used.

   Example:
      /EXTERNAL_REFERENCE="DEBUG=TRUE"


/FULL

	/NOFULL (D)
	/FULL

   If the destination directory already contains a file with the name of the
   body file for the argument file spec, replace it with the generated body
   stub. If /FULL is not used and there is already a body file, this existing
   body file is not replaced.


/HEADER

	/HEADER[=header-option]

   Specifies the form of the comment header above the generated body stub.
   If no /HEADER qualifier is specified, there is no comment header.
   header-option is one of the following:

      
      GENERAL (D)  Put a sample comment header into the body stub.

      SPEC         Put the comment header (i.e., all the comments preceding
                   the compilation unit) from the source of the library unit
                   declaration into the body stub.


/INDENTATION

	/INDENTATION=nnn

   (nnn is a non-negative integer). Set the indentation level in the generated
   body stub to nnn. nnn=0 means "no indentation". Default insdentation is 3.


/KEEP

	/NOKEEP (D)
	/KEEP

   Do not delete the tree file (i.e., the snapshot of the compiler internal
   structures used by gnatstub) after creating the body stub.


/LINE_LENGTH

	/LINE_LENGTH=nnn

   (n is a non-negative integer). Set the maximum line length in the body stub
   to nnn. Default is 78.


/MESSAGES_PROJECT_FILE

	/MESSAGES_PROJECT_FILE[=messages-option]

   Specifies the "verbosity" of the parsing of project files.
   messages-option may be one of the following:

      DEFAULT (D)   No messages are output if there is no error or warning.

      MEDIUM        A small number of messages are output.

      HIGH          A great number of messages are output, most of them not
                    being useful for the user.

/OUTPUT

	/OUTPUT=filespec

   Body file name. This should be set if the argument file name does not follow
   the GNAT file naming conventions. If this switch is omitted, the default
   name for the body will be obtained from the argument file name according to
   the GNAT file naming conventions.


/PROJECT_FILE

	/PROJECT_FILE=filename

   Specifies the main project file to be used. The project files rooted
   at the main project file will be parsed before any other processing.
   The source and object directories to be searched will be communicated
   to gnatstub through logical names ADA_INCLUDE_PATH and ADA_OBJECTS_PATH.


/QUIET

	/NOQUIET (D)
	/QUIET

   Quiet mode: do not generate a confirmation when a body is successfully
   created, and do not generate a message when a body is not required for an
   argument unit.


/SEARCH

	/SEARCH=(directory[,...])

    When looking for source files also look in directories specified.


/TREE_FILE

	/TREE_FILE[=treefile-option]

   Specify what to do with the tree file. 
   treefile-option is one of the following:

      OVERWRITE (D)  Overwrite the existing tree file. If the current
                     directory already contains the file which, according
                     to the GNAT file naming rules should be considered
                     as a tree file for the argument source file,
                     gnatstub will refuse to create the tree file needed
                     to create a sample body unless this option is chosen.

      SAVE           Do not remove the tree file (i.e., the snapshot
                     of the compiler internal structures used by gnatstub)
                     after creating the body stub.

      REUSE          Reuse the tree file (if it exists) instead of creating it.
                     Instead of creating the tree file for the library unit
                     declaration, gnatstub tries to find it in the current
                     directory and use it for creating a body.
                     If the tree file is not found, no body is created.
                     This option also implies `SAVE', whether or not the latter
                     is set explicitly.

/VERBOSE

	/NOVERBOSE (D)
	/VERBOSE

   Verbose mode: generate version information.

2  XREF

   The compiler generates cross-referencing information, which is saved in
   the .ALI files. This information indicates where in the source each
   entity is declared and referenced.

   The tools XREF and FIND take advantage of this information to provide the
   user with the capability to easily locate the declaration and references
   to an entity. These tools are quite similar, the difference being that
   FIND is intended for locating definitions and/or references to a
   specified entity or entities, whereas XREF is oriented to generating a
   full report of all cross-references.


3  Parameters

filespec[,...]

   The search will be restricted to these files. If none are given, then
   the search will be done for every library file in the search path.
   These file must appear only after the pattern or sourcefile.


3  Qualifiers

/ALL_FILES

	/NOALL_FILES (D)
	/ALL_FILES

   If this switch is present, FIND and XREF will parse the read-only
   files found in the library search path. Otherwise, these files will
   be ignored. This option can be used to protect Gnat sources or your
   own libraries from being parsed, thus making FIND and XREF much
   faster, and their output much smaller.


/DERIVED_TYPES

	/NODERIVED_TYPES (D)
	/DERIVED_TYPES

   Output the parent type reference for each matching derived types.


/EXTERNAL_REFERENCE

	/EXTERNAL_REFERENCE="name=val"

   Specifies an external reference to the project manager. Useful only if
   /PROJECT_FILE is used.

   Example:
      /EXTERNAL_REFERENCE="DEBUG=TRUE"


/FULL_PATHNAME

	/NOFULL_PATHNAME (D)
	/FULL_PATHNAME

   If this switch is set, the output file names will be preceded by their
   directory (if the file was found in the search path). If this switch
   is not set, the directory will not be printed.


/IGNORE_LOCALS

	/NOIGNORE_LOCALS (D)
	/IGNORE_LOCALS

   If this switch is set, information is output only for library-level
   entities, ignoring local entities. The use of this switch may
   accelerate FIND and XREF.


/MESSAGES_PROJECT_FILE

	/MESSAGES_PROJECT_FILE[=messages-option]

   Specifies the "verbosity" of the parsing of project files.
   messages-option may be one of the following:

      DEFAULT (D)   No messages are output if there is no error or warning.

      MEDIUM        A small number of messages are output.

      HIGH          A great number of messages are output, most of them not
                    being useful for the user.

/NOSTD_INCLUDES

	/NOSTD_INCLUDES

   Do not look for sources in the system default directory.


/NOSTD_LIBRARIES

	/NOSTD_LIBRARIES

   Do not look for library files in the system default directory.


/OBJECT_SEARCH

	/OBJECT_SEARCH=(directory,...)

   When searching for library and object files, look in the specified
   directories. The order in which library files are searched is the same
   as for MAKE.

/PROJECT

	/PROJECT=file

   Specify a project file to use. By default, FIND and XREF will try to
   locate a project file in the current directory.

   If a project file is either specified or found by the tools, then the
   content of the source directory and object directory lines are added
   as if they had been specified respectively by /SOURCE_SEARCH and
   /OBJECT_SEARCH.


/PROJECT_FILE

	/PROJECT_FILE=filename

   Specifies the main project file to be used. The project files rooted
   at the main project file will be parsed before doing any processing.
   The source and object directories to be searched will be communicated
   to gnatxref through logical names ADA_INCLUDE_PATH and ADA_OBJECTS_PATH.


/SEARCH

	/SEARCH=(directory,...)

   Equivalent to /OBJECT_SEARCH=(directory,...) /SOURCE_SEARCH=(directory,...)


/SOURCE_SEARCH

	/SOURCE_SEARCH=(directory,...)

   When looking for source files also look in the specified directories.
   The order in which source file search is undertaken is the same as for
   MAKE.


/TAGS

	/NOTAGS (D)
	/TAGS

   Print a 'tags' file for vi.


/UNUSED

	/NOUNUSED (D)
	/UNUSED

   Output only unused symbols. This may be really useful if you give your
   main compilation unit on the command line, XREF will then display
   every unused entity and 'with'ed package.


2  Language_Topics

   For more information, refer to the GNAT Reference Manual.
